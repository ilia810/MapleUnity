## 1. Character.nx Structure (v83 MapleStory)

**Top-Level Organization:** In MapleStory v83, `Character.nx` contains multiple **`.img` entries** at its root, each corresponding to a character-related asset. For example, base **skin sprites** are stored under numeric names like `00002000.img`, `00002001.img`, etc., representing different skin colors (IDs 2000, 2001, etc.). Similarly, other character assets like hair and face styles are organized by ID under categories (e.g. `Hair/` and `Face/` folders with their own `.img` files). Each `.img` file encapsulates all frames and animations for that item or body part. For instance, the skin `00002001.img` contains sub-nodes for actions like “stand”, “walk”, “jump”, “ladder”, etc., each of which holds the frames for that animation. Equipment items (hats, weapons, etc.) are likewise stored as separate `.img` files in their category folders (e.g. `Cap/00012345.img` for a hat with ID 12345). The structure is optimized to avoid duplication – common animations are defined once and reused for similar items. (For example, skin `2000` includes a comprehensive set of animations, whereas other skins like `2001-2005` include fewer nodes and may reference the default frames).

**Sprites and Animations:** Each `.img` entry contains **animation folders** for each action state. Common animation node names (matching MapleStory’s internal “stance” names) include `stand1`, `stand2` (idle stances), `walk1`, `walk2` (walking), `jump` (jumping/falling), `ladder`/`rope` (climbing), `sit` (sitting), various attacks like `stabO1`, `swingO1` (weapon attack motions), etc.. Within each animation node are **frame sub-nodes** labeled `0`, `1`, `2`, ... corresponding to animation frames in order. For example, `stand1` might have frames `0, 1, 2` (3 frames), while `walk1` has frames `0-3` (4 frames). Each frame node contains the actual image(s) and properties for that frame. **Sprite images** are typically broken into parts; for instance, a frame might have a `body` part (torso/legs) and an `arm` part so they can layer correctly with equipment. The Unity NX loader code notes that *“each frame contains part nodes like ‘body’, ‘arm’, etc.”*. Under a frame node, these part sub-nodes hold the image data and positioning info for that piece of the frame.

**Origins and Coordinates:** MapleStory defines an **origin point** for each sprite, stored as a 2D vector (often under a child named `origin` or implicitly in the image node). This origin is the pivot offset from the top-left corner of the image that corresponds to the character’s reference point in-game. In practice, this is usually the point where the sprite aligns to the character’s position (often around the character’s feet for body frames). The NX loader converts any `Point` values to Unity `Vector2`, preserving these offsets. Additionally, frames often include a `head` coordinate (stored as a point under the frame) which marks where to attach the character’s face and hair on that frame. This allows face and hair images (which are separate assets) to be drawn at the correct position relative to the base body.

**Layering and Z-Order:** The character’s composite sprite is constructed from multiple layered images. The NX structure sometimes explicitly separates layers using sub-folders like “front” and “back”. For example, hair `.img` files have a `back` section and a `front` section, each containing a `head` image – the back image is drawn behind the character’s head, and the front image on top. Equipment sprites also follow a layering convention. The MapleUnity code defines rendering order indices for each equipment category – e.g. shields and capes have negative z-index to render **behind** the body, while gloves, coats, etc. render above the body in increasing order, up to weapons which are on top. This corresponds to MapleStory’s draw order (e.g. capes behind, then body, then other equips, with weapons and hats above). In the NX data, some equips may be split into multiple pieces to facilitate layering (for instance, a long coat might have separate parts drawn behind vs. in front of legs). The game uses consistent naming conventions or node ordering to distinguish these, which the rendering system must handle.

**Summary:** In short, `Character.nx` is a hierarchical data store: **root -> item .img -> animation -> frame -> parts/values**. Each frame provides the **image bytes, origin offsets, and any other properties** needed to render that pose. The presence of `info` sub-nodes under each `.img` provides metadata like the equip slot (e.g. `islot "Bd"` for body/skin, `islot "Hd"` for head/hair). This structure enables assembling a full character by layering the appropriate frame images from the base body and all equipped items according to their origins and z-orders.

## 2. Missing `SpriteLoader` Implementation

The `SpriteLoader` class is responsible for converting NX image data into Unity engine `Sprite` objects. In the current code, calls like `SpriteLoader.LoadSprite(nxNode)` are placeholders – the implementation needs to:

* **Extract Image Data:** Each NX `NXNode` that corresponds to an image contains the raw pixel data (often as PNG bytes). The NX reading library (reNX/NoLifeNx) provides these bytes through `NXValuedNode<byte[]>`. The existing code even demonstrates retrieving a byte array from a “body” node in Character.nx. In one test, wrapping an NX node with `RealNxNode` yielded a `byte[]` of PNG data. The `SpriteLoader` should take such an NX node, find the image byte data, and create a Unity `Texture2D` from it. This involves decoding the PNG (which Unity can do via `Texture2D.LoadImage(byte[])`).

* **Create Unity Sprite:** Once a `Texture2D` is created, a `Sprite` can be generated via `Sprite.Create`. It’s crucial to apply the **correct pivot (origin)**. MapleStory’s origin is given as an offset from the top-left, whereas Unity’s sprite pivot is typically specified from the bottom-left (or normalized \[0,1] range). `SpriteLoader` should read the origin (e.g. an `NXValuedNode<Point>` under the image node) and convert it to Unity’s coordinate space. In practice, if an image is width×height, and Maple’s origin is (ox, oy) from top-left, the Unity pivot can be set to `(ox/width, 1 - oy/height)` to match it. This ensures the sprite, when positioned at the character’s coordinate, aligns exactly as it did in MapleStory. The NX loader already captures point values into `Vector2`, so `SpriteLoader` can likely obtain an `origin` vector directly. The coordinate conversion might also need to handle Y-axis inversion (since Unity’s Y grows upward).

* **Pixels-Per-Unit Scaling:** MapleStory uses pixel coordinates, and MapleUnity appears to use **100 pixels = 1 Unity unit** scale (as noted by movement speeds). When creating the sprite, we should set `pixelsPerUnit = 100` so that 100px in the sprite equals 1 world unit. This way, the character’s movement and size remain proportionate to MapleUnity’s physics (e.g. a 32px tall sprite \~0.32 units).

* **Handle Multiple Parts:** In some cases, an NX frame node might not be a single image but a container of multiple part images (e.g. a frame node might directly have children “body” and “arm” which are separate images). The `SpriteLoader.ConvertCharacterNodeToSprite()` likely intended to compose multiple parts if needed. A straightforward approach, however, is to load each part as a separate `SpriteRenderer` layer (as done in MapleCharacterRenderer). Thus, `SpriteLoader.LoadSprite(node)` can focus on a single image node at a time. For complex cases (like character frame nodes containing sub-nodes), the code can either locate the specific sub-node (e.g. `frameNode["body"]`) before loading, or if passed a container, choose the appropriate child automatically. The current stub calls attempt this (e.g. `LoadCharacterHead` finds the “head” sub-node and then calls `LoadSprite` on it).

* **Maple Coordinate System Conversion:** Aside from pivot adjustments, MapleStory’s coordinate system for placing sprites in the world should be considered. The game’s **origin for characters is typically at their feet**, and the NX origins are set so that (x=0, y=0) align the sprite correctly. Because Maple’s Y axis increases downward on screen, the origin’s Y from top-left must be converted as described above. Additionally, Maple’s coordinates are in pixels; MapleUnity’s physics and transforms likely treat 1 unit = 100px, so positions and velocities have already been scaled accordingly. Ensuring the sprite’s pixels-per-unit is correct (as noted) will keep the visual alignment consistent.

In summary, implementing `SpriteLoader` involves decoding image bytes to `Texture2D`, creating a Unity `Sprite` with the proper **pivot offset and scale**, and returning it. This will fill the gap so that `NXAssetLoader.LoadCharacterBody/Head/Hair/etc.` can return actual Sprites instead of `null`. With `SpriteLoader` in place, calls in the code like:

```csharp
var bodySprite = NXAssetLoader.Instance.LoadCharacterBody(skin, stateName, frame);
bodyRenderer.sprite = bodySprite;
```

will start showing the real MapleStory character sprite on the screen (instead of the placeholder rectangle).

## 3. Animation Data Format in NX

Each animation frame in the NX data comes with timing and other properties. Specifically, the NX frame node typically contains:

* **Frame Delay:** The duration to display that frame (in milliseconds). In the MapleStory data, this is stored in a child value named `delay` under each frame. If omitted, the game defaults to 100 ms (0.1 sec) per frame. The open-source client code confirms this: it reads `src["delay"]` and uses 100ms if the value is 0. This means most character animations run at 10 frames per second unless specified otherwise. Some special animations (e.g. skill effects) might use custom delays per frame. The MapleUnity prototype currently uses a fixed 0.1s frame step for character animation, which aligns with that default. In a full implementation, these `delay` values can be read from NX to precisely match MapleStory’s timing (ensuring, for example, slower attack swings vs. faster idle blinks if applicable).

* **Frame Sequence & Looping:** Animations are defined simply by the sequence of frame nodes (0,1,2,…). The game plays them in order at the given delays. Looping is handled by the client’s logic: idle and walking animations loop continuously, while one-off actions (like an attack or a jump) play through once. The NX doesn’t usually have an explicit “loop” flag for character stances, but it does sometimes include a boolean `zigzag` property for certain animations. If `zigzag=true`, it indicates a **ping-pong** playback (frames 0→1→2→1→0, etc.) instead of looping back to the start. This can be used for animations that should oscillate (though it’s more common in effect animations than player stances). In general, MapleUnity can decide loop vs. one-shot based on the animation type (e.g. “stand” loops, “attack” does not, unless the player keeps attacking). The `CharacterDataProvider` in GameData maps `CharacterState` to the appropriate animation name and also knows the number of frames for each (e.g. “walk1” has 4 frames, “jump” has 1 frame). This frame count dictionary is used to wrap the frame index around when looping.

* **Equipment Animations:** Equip items have their own frames corresponding to the character’s frames. The format is parallel. For example, a coat item’s NX file will have the same animation subfolders (“stand1”, “walk1”, “jump”, etc.), containing images that align with each frame of the base body. If an equip doesn’t have a certain animation (for instance, a chair might not have “walk” frames), the game either hides that part or uses a default. Typically, wearable equips have frames for all standard actions a character can perform while wearing them. The equip frame’s `delay` isn’t needed independently because the timing is dictated by the character’s animation cycle. What matters is the equip frame’s *positioning*: the image’s origin ensures it lines up on the character. For multi-part equips, the NX might split images into `front`/`back` as mentioned (e.g. a long coat may have a “back” piece that goes behind the legs). These parts are stored in the item’s `.img` (often under sub-nodes named “mail”/“female” or “front”/“back” depending on gender and layering). The MapleCharacterRenderer will need to render all relevant equip sprites each frame. The code already categorizes equips by slot and sets the sprite in the corresponding renderer, using the same `state` and `frame` index as the body. This ensures, for example, when the body is on frame 2 of “walk”, the pants and shoes also show frame 2 of their “walk” animation, so everything stays in sync.

* **Additional Frame Properties:** MapleStory frames can also have optional properties like transparency (`a0`/`a1`) and scale (`z0`/`z1`) for special effects (commonly used in animated UI or background elements). For characters, these are rarely used except in specific cases (e.g. some NX might use slight scaling for breathing animations, or fading for ghost images). The open-source client code handles these: it reads `a0/a1` for start/end alpha and `z0/z1` for start/end scale. If present, the engine interpolates between those values over the frame’s duration. In v83 character sprites, one typically wouldn’t see noticeable scaling/alpha changes, so this is a minor concern. But it’s good to be aware that NX supports it (for example, the “heal” animation might fade the character slightly, etc.).

**Equipment Specifics:** One noteworthy aspect is **gender variations** – some equip `.img` files contain separate subfolders for male and female sprites. In v83, certain items that differ by gender (like overall outfits) are stored together, with sub-nodes like “male” and “female” each containing the animation frames. The loader would need to pick the correct section based on the character’s gender. (If not implemented, one might see a null if the wrong gender branch is accessed.) Similarly, some equip categories (like Weapons) have multiple animation sets depending on weapon type. MapleStory uses different animations for one-handed vs two-handed, etc., but these are usually distinguished by animation name (e.g. “stab” vs “swing” frames as in the base body). The base `Player.cs` state machine likely chooses which attack animation to trigger based on weapon class. The NX data for a weapon item will correspondingly have frames for those motions (e.g. a spear’s item .img might only have “stab” frames if spears always stab). Ensuring the state-to-animation mapping covers these cases is important (the provided mapping uses `stabO1`, `swingO1` as default attack states, but more logic may be needed for variety of weapons).

In summary, **frame timing is stored per frame in NX**, typically 100ms default, and **animation sequences** are simply the ordered frames under each action. Equip and body animations share the same naming and frame indexing, making it straightforward to keep them in sync – the key is aligning them via origin and drawing in the right order. The event system or game logic will signal when to play/loop these animations, but the data tells us *what to draw* and *for how long*.

## 4. Current Code Integration Points

The project has a clear separation between data, logic, and view for handling player animations, but some parts are stubbed out. Here’s how to integrate them:

* **CharacterDataProvider & Sprite Loading:** The `CharacterDataProvider` (GameData layer) is designed to fetch sprite frames given a character state. It translates a `CharacterState` (GameLogic enum) into the corresponding Maple animation name and frame number, then calls the `NXAssetLoader` to get the Sprite. Currently, because `SpriteLoader` isn’t implemented, these calls return `null`. After implementing `SpriteLoader`, `CharacterDataProvider.GetBodySprite/HeadSprite/etc.` will start returning actual `SpriteData`. The mappings in `CharacterDataProvider` should be reviewed for completeness – e.g. it maps basic states like Walk, Jump, etc., but future states like attacking or climbing are also considered (CharacterState.Attack1 -> “stabO1”). These correspond to the base animations available in `Character.nx`. The provider also assigns a frame count for each animation so the view knows how many frames to cycle. This dictionary might need expansion if new animations (or weapon-specific ones) are added.

* **MapleCharacterRenderer (GameView layer):** This MonoBehaviour is responsible for constructing the visible character from all its sprite parts. In the current code, `MapleCharacterRenderer` creates separate `SpriteRenderer` objects for each layer of the character (body, head, face, hair, and each equip slot) and assigns them specific **sorting orders**. These sorting orders were chosen to match MapleStory’s draw order (as seen in the GetEquipmentZIndex logic: body=0, face/hair a bit above, etc., weapon highest, cape/shield negative behind). The `Initialize` method of MapleCharacterRenderer attaches it to a `Player` object from GameLogic and an `ICharacterDataProvider`. Once sprites can be loaded, the `UpdateSprites()` method will fetch the correct frame for each part and assign it to the corresponding renderer. This method is called whenever the animation frame changes or appearance changes. Right now, MapleCharacterRenderer calls `NXAssetLoader.Instance` directly to get sprites (bypassing the interface); it could be refactored to use CharacterDataProvider for cleaner separation (e.g. `characterData.GetBodySprite(skin, state, frame)`). Either approach can work once SpriteLoader is functional.

* **State and Animation Timing:** The player’s logic state is accessible via `player.State`. MapleCharacterRenderer currently polls this each `Update()` to determine if the character’s state has changed. For example, if `player.State` goes from Standing to Walking, it will detect a new state, reset the animation frame to 0, and start the walk cycle. The code in `Update()` also increments the frame on a timer (using a fixed 0.1s frame duration) and loops it based on the known frame count for that state. This is a simple way to drive animations. We might enhance this by using the actual `delay` from NX for each frame, but that would require a bit more data plumbing. For now, the fixed tick is acceptable (Maple’s default 100ms) and the frame counts ensure proper looping. One consideration: **jump/fall animations** in MapleStory – v83 uses a single “jump” frame until landing. The code maps both Jump and Fall states to the same “jump” animation, which has 1 frame, so it will not animate while in air (just holds that pose). That matches MapleStory behavior (only one sprite while airborne). The renderer should handle the landing event to possibly play a “land” or transition back to standing. Currently, it will simply switch state back to Stand when the logic state changes (likely when the Player’s vertical velocity goes to zero and they’re grounded, logic sets state to Standing).

* **IPlayerViewListener events:** The Player logic triggers events like `OnAnimationEvent(AnimationEvent)` for specific moments (e.g., `Jump` event when taking off, `Land` when hitting ground, `Attack` when an attack action starts, etc.). In the simplified approach above, the continuous polling covers some of these (e.g. state change covers jump start and landing implicitly). However, for more nuanced animations, listening to events is useful. For instance, if the Player fires an `Attack` event, MapleCharacterRenderer could set a temporary attack animation state that might not be captured just by `player.State` (since the code didn’t define an Attack state in PlayerState enum as of now). Implementing `IPlayerViewListener` in MapleCharacterRenderer would allow:

  * **Jump/Land:** On `Jump` event, you might play a jump sprite (already done by state change to Jump). On `Land` event, you could play a landing dust effect or simply ensure the next frame returns to idle.
  * **Attacks:** On `Attack` event, set `currentState = Attack1 or Attack2` depending on weapon, and maybe prevent it from looping. The event could also carry info like attack type or skill, which MapleCharacterRenderer uses to choose the correct animation (e.g. a stab vs swing). After the attack animation’s last frame, it should revert to standing or whatever is appropriate.

  Integrating these events ensures **one-shot animations** (attacks, casting a skill, etc.) play fully even if the logic state is only momentary. The good news is the underlying event system and enumeration (`PlayerAnimationEvent`) is already defined in the `Player` class, covering things like Jump, Land, StartWalk, StopWalk, Attack, etc.. Hooking MapleCharacterRenderer to those will involve adding it as a listener (likely via `player.SubscribeView(listener)`). Then implementing `OnAnimationEvent(eventType)` to handle each relevant event. For example, on `StartWalk` you might switch to walk state (already handled by polling, but event could be redundant), on `Attack` set an internal flag to play attack animation once (the code might then temporarily override the state in UpdateSprites or use a separate mechanism to animate attack).

* **Empty MapleCharacterRenderer:** The user noted it’s currently empty – the snippet we have actually shows a partial implementation (creating layers, updating frames). If in the actual project MapleCharacterRenderer was just a stub, the plan would be to implement it similar to the code above. That is: create child GameObjects with SpriteRenderers for each layer in `Initialize()`, then each frame (or on events) update those SpriteRenderers’ `sprite` property using CharacterDataProvider or NXAssetLoader. The architecture shown in the code is solid: a separate renderer per part, all under a parent object that follows the Player’s position. This allows easy flipping for left/right (just setting `flipX` on all renderers together). The sorting layer “Player” and individual `sortingOrder` ensure the correct draw priority regardless of the character’s world position. We should maintain this structure.

* **Testing & Debugging:** After integrating, we should test a few scenarios. For instance, ensure that changing `skinColor`, `hairId`, etc., updates the appearance (the code provides `SetCharacterAppearance` to assign new IDs and then calls `UpdateAppearance()` to refresh sprites). Also verify the character flips correctly when turning directions, and that layering looks right (e.g., with a cape equipped, the capeRenderer sprite is behind the body, etc.). The logging in the code (currently verbose with `Debug.Log`) can help verify that sprites are loading (e.g., it logs “Body sprite loaded: name (widthxheight)”). Once working, those debug lines can be removed or toned down.

In essence, the integration involves **connecting the dots**: Implement `SpriteLoader` so CharacterDataProvider yields sprites, use CharacterDataProvider (or NXAssetLoader directly) in MapleCharacterRenderer to set those sprites on the multiple renderers every frame or on state changes. Also, utilize the event system for discrete actions to complement the continuous state polling. With these pieces in place, the placeholder blue rectangle will be replaced by a fully assembled MapleStory character sprite that animates properly.

## 5. Priority Implementation Path

To quickly get visible results and then iteratively add complexity, I recommend the following roadmap:

**Phase 1: Basic Standing Sprite** – *Goal: Replace the blue rectangle with a MapleStory character idle image.*

1. **Implement `SpriteLoader` for static images** – Focus first on loading a single frame. Test by manually loading, for example, `00002000.img/stand1/0/body` via the NXAssetLoader (as the code already attempts in `MapleCharacterRenderer.Initialize`). If successful, you should get a Texture2D and a Sprite for the base body. Use that to set the `bodyRenderer.sprite`. Also load a hair and face sprite (e.g., find a hairId and faceId in the NX data to test) and assign to `hairRenderer` and `faceRenderer`. At this stage, you can hard-code a particular hair/face or use the defaults already in the code (faceId = 20000, hairId = 30000). Confirm that the sprites appear in the GameView with correct alignment. This will validate that the NX reading and sprite creation pipeline works (and that any pivot math is correct, as the character’s feet should align with where the collider/physics expect).

2. **Integrate CharacterDataProvider** – Once a single frame can load, update MapleCharacterRenderer to use `characterData.GetBodySprite(...)` etc., instead of directly calling NXAssetLoader. This isn’t strictly necessary (the direct calls can work too), but using the provider will ensure consistency (it uses the same ConvertState logic as the logic layer) and will be useful when we add network-sync or other features. Make sure CharacterDataProvider is getting the NXAssetLoader instance and that the NX files are registered (the NX files are likely loaded in some startup code or via editor scripts – double-check that `NXAssetLoader.Instance.RegisterNxFile("character", NxFile)` is being done as per setup). With the provider, calling `GetBodySprite(skin, state, frame)` should return a `SpriteData` object; you can extend `SpriteData` to carry the Unity Sprite or just modify it to carry the sprite’s Texture2D and pivot. Adjust accordingly so that MapleCharacterRenderer can get the Unity Sprite to assign to the renderer.

3. **Display Idle Character** – Set the player’s initial state to Standing and call `UpdateSprites()` once. You should now see a fully drawn character (base body, hair, face, etc. layered). This minimal viable product replaces the rectangle with the actual art.

**Phase 2: Animation Frames** – *Goal: Character switches sprites when walking, jumping, etc.*

1. **Frame Timer Loop** – Leverage the existing logic in MapleCharacterRenderer.Update: it uses a simple timer (`animationTimer`) and FRAME\_DURATION (which we’ll keep as 0.1s for now) to advance frames. Ensure that `characterData.GetAnimationFrameCount(state)` returns correct counts (the provided dictionary covers most, but if you use Attack states you might add those). When `currentFrame` exceeds the max, wrap to 0. This will handle looping animations.

2. **State Changes** – The code already maps `Player.State` (GameLogic) to a simplified `CharacterState` (Stand, Walk, Jump, etc.). Confirm that as you move the player (using input), the Player.State changes accordingly (e.g. from Walking to Standing when you stop). The MapleCharacterRenderer should detect this and reset `currentFrame` to 0 on change, which it does. Test walking: the sprite should cycle through the walk frames. Test jumping: it should switch to the jump frame (one frame) and hold it; upon landing (state back to Stand), the idle animation should resume from frame 0. You may need to tie into the landing event if you notice a hitch (for example, if the stand animation was paused on a non-zero frame when you jumped, you might want to reset to frame 0 on land – the code already resets on any state change, which covers this).

3. **One-shot Animations (Attacks)** – At this point, movement animations work. Attacks and other actions remain. If the game logic has an Attack action (e.g. pressing a key sets Player.State = Attacking briefly, or triggers an event), we should handle it. Perhaps introduce a `PlayerState.Attacking` and map it in GetCharacterState to a CharacterState like Attack1. If using events, on Attack event you could manually set MapleCharacterRenderer.currentState = Attack and not rely on the polling for that moment. Play the attack animation through once (do not loop – you can avoid looping by not resetting frame to 0 when it finishes, or by using the event to know it’s done). Since v83 has very fast attacks (few frames), you might get away with letting the normal loop run but immediately changing state back to Stand after one cycle – the logic could do this or you handle it by tracking that an attack was in progress. This part can be refined later; initially, focus on getting the visual frames to show for an attack input.

4. **Climbing and Other States** – If ladder/rope climbing is implemented in logic, ensure those show the correct frames (they have 2 frames alternating). Crouch (prone) is a single frame. Swimming (if applicable) could be treated similar to walking with its frames. The groundwork in CharacterDataProvider and the NX data structure covers these – it’s mostly a matter of testing each and possibly adjusting the state mapping (for example, the code maps PlayerState.Crouching to CharacterState.Prone which uses the lying down sprite – that might be fine for crouch, or MapleStory might have a separate “sit” for chairs). Adjust as needed once visible.

**Phase 3: Full Character & Equipment Layering** – *Goal: Draw all equipped items and ensure layering is correct.*

1. **Hair & Face:** Make sure the face expression can change. Currently, CharacterExpression is always Default. We could tie blinking or other expressions to events (e.g. a timer for blink, or a damage event for “hit” face). For now, confirm the default face draws correctly at the head position. If the face or hair appears misaligned, it could be an origin issue – those assets have their own origins in NX. The `LoadFace` and `LoadHair` functions use the separate NX files (Face and Hair folders), which include their own origin points (often the “head” point in body frames is where these should align). If misalignment occurs, verify that the `headRenderer` or `faceRenderer` has the correct relative position. In our setup, all sprite renderers are children of one GameObject and share the same position (0,0). This means if the Sprite pivots are correct, everything should line up automatically. If not, one might consider adjusting the transform of specific layers (though ideally not needed).

2. **Equipped Items:** Enable drawing for equips. The MapleCharacterRenderer update loop already iterates `player.GetEquippedItems()` and loads each equip sprite for the current frame. We need to ensure `player.GetEquippedItems()` returns the correct IDs (this depends on how equipment is stored in Player – likely a dictionary of slots to itemIDs as hinted by the loop). Once that’s feeding in, the code uses the same `GetEquipmentCategory` logic to find the NX folder name and loads the sprite. This should yield the correct part image. One thing to check is that for multi-part equips (like hair with front/back, or two-handed weapon drawn in parts), `LoadEquipment` might return a container node rather than a direct image. If `SpriteLoader.LoadSprite` is smart enough to handle a container (maybe by taking the first image child), it will work. If not, you might need to specify sub-nodes (e.g., some items store the main image under a child named after the part, such as “weapon” or “cape”). In practice, many equip frames consist of a single image (the item’s sprite), so likely it will just work. Test with a simple equip: for example, give the player a hat itemId in code and see if `hatRenderer.sprite` shows it on the character’s head. If it shows but positioning is off, double-check the origin. Hat items in MapleStory typically have an origin such that (0,0) is where it fits on the head. The code currently doesn’t explicitly use the `head` coordinate for equips – it relies on the sprite’s own pivot. Fortunately, Nexon’s data usually sets the equip image’s origin to align with either the character’s origin or some reference point. If a particular equip is off, we may need to incorporate the character’s `head` point. A robust approach could be: when drawing an equip that should align to the body (like a hat to the head), offset it by the difference between body’s head point and equip’s origin. However, this might be overkill; see if the default works first.

3. **Layer Order Verification:** Ensure that each equip appears in the right draw order. The MapleCharacterRenderer created layers with explicit sortingOrder matching the Z index logic. If something is out of order (e.g. weapon appearing behind body), adjust the sortingOrder or the assignment. According to the code: Shield = -2, Cape = -1, Body = 0, then Earring(1), FaceAcc(2), EyeAcc(3), Bottom(4), Coat(5), Shoes(6), Glove(7), Hat(8), Weapon(9). These were applied when creating the SpriteRenderers, so it should already correspond (they named “Top” for coat with order 5, etc.). If a discrepancy is found (for instance, maybe they used “shieldRenderer.sortingOrder = -2” which they did), it should match the intended layering. Unity’s SortingLayer “Player” is presumably configured to ensure players render in front of map elements appropriately. As long as all parts share the same SortingLayer and only differ in order, they will move together with the character.

4. **MapleCharacterRenderer Event Handling:** Finally, integrate the event system if needed for polish. For example, subscribe to the Player’s `AnimationEventTriggered` event. Use it to handle things like playing a “landing” effect or synchronizing sound. You could also use it to trigger an expression change: e.g., on `PlayerAnimationEvent.Land` you might set the face to a “smile” for a brief moment, or on `TakeDamage` (if such event exists) set the face to “hit” for that frame. This is an enhancement on top of the core animation system, but it demonstrates the power of having those events from the GameLogic layer. The current code’s simplicity (polling state) covers the essentials, so events can be integrated gradually.

**Phase 4: Advanced Features & Optimization** – *Goal: Approach parity with the original client’s visual details.*

1. **Full Animation Data Use:** Upgrade the animation timing to use NX’s `delay` values per frame instead of a constant. This would involve reading the `delay` from the NX node when loading frames and storing it (perhaps in the SpriteData). Then MapleCharacterRenderer could use a dynamic timer (e.g., each frame use that frame’s delay/1000 as duration). This would make, say, the “alert” animation blink at the exact rate Nexon intended. It’s a refinement that can be done after the system is working.

2. **Facial Expressions and Blink:** Implement a timer for blinking (Maple characters blink every \~4 seconds by cycling to the “blink” face for one frame). The NX data for faces includes a “blink” frame. You can periodically call `faceRenderer.sprite = LoadFace(faceId, "blink")` for a short duration. Also handle other expressions triggered by events (anger, etc., if emotes are used).

3. **Multiple Weapon Stance Support:** Extend the logic so that if the player equips, say, a two-handed sword, the CharacterState uses “swingO3” or appropriate animations. This might need identifying weapon types from itemId and having more entries in the state mapping or event triggers for different attacks. This ensures that a dagger stab and a sword swing use the correct body motion. The data for these is present in `00002000.img` which contained many skill and attack animations. The CharacterDataProvider’s dictionary can be expanded or made dynamic if needed (for example, if weapon type is sword, use swing frames, if spear, use stab, etc.).

4. **Performance & Caching:** Currently, each frame change calls `NXAssetLoader` to fetch a sprite, which in turn likely traverses the NX tree and decodes PNG each time. This could be optimized by caching `Sprite` or `Texture2D` objects. A simple cache could be a dictionary key’d by `(skin, state, frame)` to a Sprite. Unity also can atlas or pack sprites, but since these are runtime-generated, caching in memory is the way. Given v83 character sprites aren’t very large, caching the whole set for the current character is reasonable. You might implement this in CharacterDataProvider or SpriteLoader (e.g., keep a Dictionary for recently used sprites). This will eliminate any stutter from decoding images on the fly. Since characters change appearance infrequently, the cache can persist per character.

5. **Finalize MapleCharacterRenderer:** Once everything is working, MapleCharacterRenderer should be the one-stop component for rendering the player. Remove the old SimplePlayerController sprite (the blue box) – presumably, PlayerView was using SimplePlayerController before. Now PlayerView (the object following the player logic) should instantiate a MapleCharacterRenderer instead. Ensure PlayerView doesn’t double-render (the code likely was structured to use either the simple or the advanced renderer, but not both). After this swap, the player should appear with the Maple sprite in-game.

By following this implementation path, we tackle the highest impact pieces first (display something, then animate it, then add layers and details). The **minimal viable product** is achieved as soon as the character’s idle sprite is on screen instead of a rectangle – from there, each step adds authenticity. Considering the main blocker was understanding the Character.nx structure and decoding sprites, once `SpriteLoader` and the basic rendering loop are done, the rest is mostly using the existing system to its full potential. Each incremental improvement (proper timing, full equip support, etc.) will bring the Unity client closer to the real MapleStory look and feel.
