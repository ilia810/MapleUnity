# Coordinate Space and Anchoring of Tiles vs. NPCs/Objects

**Unified Map Coordinates:** In the MapleStory client, all map elements (tiles, NPCs, objects, etc.) use the same 2D coordinate space – positions are given in pixel units relative to the map. The game does **not** use separate coordinate systems for tiles versus other assets. For example, the C++ client simply reads the `x` and `y` from the map data for each element type. The code for loading a tile uses `src["x"]` and `src["y"]` directly to set the tile’s position. Similarly, a map object (like a sign or house in the “obj” layer) reads its `x,y` from the data into a position without conversion. And NPC spawn points (part of the “life” data) also come with an `x,y` in the same coordinate space. So **yes – all these coordinates are in one common map coordinate system** (with (0,0) typically at the top-left of the map).

**Tile Grid and Alignment:** While the engine treats the coordinates uniformly, the *visual alignment* suggests an underlying grid for tiles. Map designers usually snap floor tiles to a grid (often around 32×32 or 64×64 pixels) so that they connect seamlessly. The **tile coordinates typically correspond to the tile’s top-left corner (or defined origin)** in the map. There isn’t an explicit “tile grid” transformation in the code – tiles are placed at exact pixel positions as given. This means if a floor tile’s data says `x=100, y=200`, the engine will draw that tile image so that its origin aligns at (100,200) in world coordinates. In practice, most tile images have their origin at top-left, so the tile’s top-left pixel ends up at (100,200) on the map. (If a tile image uses a different origin, the engine accounts for it by offsetting – more on origin handling below.) The key point is that **tiles use raw map coordinates and tend to snap to consistent intervals**, but the client doesn’t enforce a specific grid size at runtime – it’s inherent in how the map was built.

**NPC/Object Position Meaning:** For NPCs and interactive objects (“life” entries like monsters or NPCs), the `X,Y` in the map data is intended to mark where that entity should stand or appear. In practice, **this usually corresponds to the entity’s **ground contact point** (its feet on the floor)**. For example, if an NPC is meant to stand on the ground, the map’s `y` coordinate will roughly be the y-coordinate of the floor at that position. However – and this is critical – the MapleStory client doesn’t just trust that value blindly. It uses the *foothold system* (the predefined walkable terrain lines in the map) to fine-tune the vertical placement of NPCs and other life.

# Footholds and Ground Alignment

**Foothold-Based Y Adjustment:** The C++ client uses foothold data to ensure characters and objects sit exactly on top of platforms. When an NPC is spawned, the code finds the foothold directly below the given `(x,y)` position and **replaces the NPC’s y-coordinate with the foothold’s y-coordinate** (essentially snapping the NPC to ground). In the code, `NpcSpawn::instantiate()` calls `physics.get_y_below(position)` to compute the proper ground Y for the NPC’s X position. This function consults the Foothold data structure and returns the Y of the surface below that point. In other words, **NPCs are positioned relative to footholds, not directly to tile images**. This answers the question: yes, NPC (and monster) coordinates ultimately rely on the foothold coordinate system. The map’s `x,y` for an NPC is more like a suggestion, and the engine will adjust the Y to match the floor.

**Small Offset (“Sink”) into the Floor:** Interestingly, the client even applies a tiny offset after snapping to the foothold. The `Physics::get_y_below` function returns `ground - 1` as the final Y position. This means the NPC is placed *1 pixel lower* than the exact foothold line. Why? Likely to avoid any gap between the character’s feet and the tile graphic – essentially making the sprite “sink” just slightly into the floor so it looks natural. It’s a subtle detail, but it indicates there is **a special hardcoded offset of 1 pixel vertically for characters on footholds**.

**Implication:** If your Unity implementation is currently using the raw map Y for NPCs/objects, they might be off by a bit. Without using the foothold data, an NPC could end up floating above the tiles or sunk too deep. For example, if the map’s NPC `y` was not exact or if the tile graphics include a ledge thickness, the NPC won’t visually line up. The original client solves this by always recalculating the Y. So to mirror MapleStory’s behavior, the Unity version should likely do the same: find the appropriate foothold at an NPC’s X position and use that Y (minus a small offset) for the NPC’s placement. This ensures NPCs **truly sit “on top of” the floor** as intended.

# Sprite Origins and Reference Points

**Tile Origin vs. NPC Origin:** All sprites in MapleStory (tiles, objects, characters) have an **origin** defined in their data – usually a pixel offset from the image’s top-left that marks the “attachment point” in the world. The MapleStory client consistently respects these origins when drawing. Internally, it uses a top-left drawing reference and subtracts the origin to position the image correctly. In the code, when a tile is drawn, the engine creates a `Texture` from the tile’s image node, which loads the image’s origin. When `texture.draw(pos)` is called, the texture uses its stored origin to offset the drawn image. Similarly, objects use an `Animation` (which also knows the frame image’s origin) and draw with `animation.draw(DrawArgument(pos, flip))`, meaning the object’s sprite is drawn such that its origin lands at `pos`. For an NPC or monster, each frame’s image has an origin (often the bottom-center of the sprite, i.e. the character’s “feet”). The NPC’s position is where that origin should be. So after the foothold adjustment gives the correct ground point, the NPC’s sprite is rendered with its foot-origin at that point.

**No Additional Per-Layer Offsets:** Aside from the foothold logic, the client does **not** add any extra random offsets to align tiles vs. objects. If everything is using the same coordinate space and the correct origins, tiles and props should naturally align. There’s no hardcoded “tile layer vs object layer” pixel shift or anything like that. So if tiles are aligning perfectly with each other (as you’ve achieved) but other assets aren’t lining up, it strongly suggests something is still missing in how the positions are handled relative to the coordinate system. The primary suspect is the foothold adjustment (since the original applies it to NPCs and some objects, but a naïve implementation might not).

# Map Loading Differences in the Code

It’s worth noting how the original client loads these elements differently:

* **Tiles and Static Objects** – These come from the map’s “tile” and “obj” sections and are placed into layers. In `MapTilesObjs.cpp`, for example, each tile’s position is read and stored as-is, and later drawn with its origin offset applied. There’s no further transformation on their coordinates. So tiles assume a common origin (usually top-left of the map), and multiple tile layers (L0, L1, etc.) stack via their z-values but share the same coordinate space.

* **NPCs/Monsters (“Life”)** – These come from the map’s “life” list. The client doesn’t immediately fix their position on load; instead it creates spawn points. When the map is rendered or the NPC is about to appear, the engine spawns it by calculating physics. The spawn logic uses `NpcSpawn::instantiate` which, as discussed, snaps the NPC to ground. This means the raw data Y might be slightly different (for instance, some maps might place an NPC a few pixels above a platform expecting it to drop down). The engine always enforces the final alignment via physics.

* **Interactive Objects (Reactors)** – These are things like treasure chests or gates (often part of the map but with state). The code handles them similarly to NPCs: `ReactorSpawn::instantiate` also calls `get_y_below` to snap reactors to footholds. So anything that should sit on the floor uses the foothold system in the original engine.

* **Backgrounds** – Just for completeness: background images (like distant scenery) use separate parallax logic and are not aligned to tiles at all, so ignore those for this issue.

**Conclusion – The “Missing Piece”:** The evidence strongly suggests that the misalignment you’re seeing (tiles vs NPCs/objects) comes from **not replicating the foothold-based alignment that the original client does**. In MapleStory’s engine, tiles use the map coordinates directly (with their image origins), but NPCs/monsters are **adjusted to the nearest foothold**. There is likely no large constant offset (like 30px or 50px) in the code – just whatever difference exists between the raw data and the foothold height (often a small amount) plus the 1-pixel sink. In Henesys (100000000), for example, all the NPCs should stand exactly on the ground tiles; if they appear a bit floated or sunk in Unity, it’s probably because Unity is using the raw `y` from the data (or perhaps an incorrect reference point) instead of the true ground Y.

**Actionables:**

* **Use foothold data for positioning life:** Implement a step to adjust NPC and object Y positions according to the foothold (if you have the foothold info from the WZ). This ensures an NPC that’s meant to stand on a platform will be at the same height the original game would place it.

* **Apply the small offset if needed:** You may even need to mimic that tiny offset (placing the sprite slightly into the ground). This could be as subtle as 1 pixel (0.01 in your scale) downward. It might seem negligible, but it can make the difference between looking like it’s floating versus perfectly grounded.

* **Verify reference points:** Double-check that for all sprites you’re using the correct origin. From what you described, you set every sprite’s pivot to top-left and then offset by the negated origin (–origin.x, +origin.y). That matches MapleStory’s approach (top-left reference). For tiles and static objects, this should be fine (their origins are typically set so they tile together correctly). For characters/NPCs, their frame origins are usually at the feet, so this should also place their feet at the coordinate. Once the coordinate itself is corrected via footholds, everything should line up.

By investigating the MapleStory C++ client, we see **no mysterious extra transform** on tile layers versus NPCs – the difference is entirely in how the Y positions are computed and aligned. In summary, **tiles and other map assets *should* share the same world coordinates, but the original game ensures that characters and objects are clamped to the floor defined by footholds** (with consistent origin offsets). Adopting that same logic in MapleUnity will likely resolve the misalignment so NPCs and objects sit properly on your nicely aligned tiles.

**Sources:**

* MapleStory C++ client code showing tile and object placement: tile uses raw `x,y` from map data and draws with its origin, and objects do similarly.
* MapleStory client code for NPC spawn using foothold adjustment: `NpcSpawn::instantiate` calls physics to get ground Y, and `Physics::get_y_below` returns the foothold Y minus 1 pixel. This indicates NPCs are snapped to terrain with a slight downward offset for perfect visual alignment.
