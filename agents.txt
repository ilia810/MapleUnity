Thanks! I’ll review both the C++ and Unity versions of the MapleStory client in your selected repositories. Based on their current state and what’s complete or missing, I’ll propose a specialized Claude Code sub-agent team with defined roles to support a complete and high-quality Unity rewrite.

I’ll let you know once the analysis and recommendations are ready.


# Building a Claude Code Sub-Agent Team for the MapleUnity Project

## Introduction & Project Overview

MapleUnity is an open-source effort to **reimplement the MapleStory v83 game client in Unity (C#)** as a clean, modern version of the original C++ client. The project adheres to strict **Test-Driven Development (TDD)** and separation-of-concerns principles, with a layered architecture separating game logic, data handling, and Unity-specific rendering. So far, core gameplay features are in place (player movement, basic combat, inventory, multiple maps, etc.), and a rudimentary UI exists. However, several major features remain **unfinished** before MapleUnity can be a fully functioning MapleStory client. According to the project roadmap, missing pieces include:

* **Networking** support to connect to a v83 server
* **Full NX asset loading** for all game content (most asset parsing issues have been solved, with only minor metadata glitches left)
* Advanced gameplay systems like **skills/abilities**, **NPC interactions (shops, dialogs)**, **quest system**, and **party system**.

Given these challenges, we propose leveraging Anthropic’s **new Claude Code “sub-agents” feature** to tackle the project in specialized facets. Claude Code now allows creating a custom **team of AI agents**, each with a focused role (for example, one agent for planning, another for coding, another for testing). By assembling an AI “dream team” of sub-agents, each expert in a specific domain, we can accelerate development while maintaining MapleUnity’s high code quality standards.

## Claude Code Sub-Agents – A Powerful New Feature

Claude Code’s sub-agents are essentially **specialized AI assistants** with their own configured persona, tools, and context. Instead of one monolithic AI trying to handle everything, Claude can delegate tasks to these niche experts. **Each sub-agent has a specific purpose and expertise**, operates in a separate context window (so it won’t clutter or confuse the main conversation), and can be guided by a custom system prompt and tool permissions. This isolation of contexts means each agent “stays in their lane,” preserving the main session’s focus while working on its specialized problem. Key benefits of using sub-agents include:

* **Context preservation:** Agents work independently on sub-tasks without polluting the main thread. For example, a debugging agent can load logs and fix code in its own space, then report back, keeping the main chat focused on high-level strategy.
* **Domain expertise:** Each agent can be configured with domain-specific knowledge or instructions, yielding higher accuracy on complex tasks. A well-tuned agent “expert” in Unity UI or MapleStory data formats will perform better in those areas than a generalist prompt.
* **Parallel and structured workflow:** We can explicitly invoke a given sub-agent for its task, or Claude may automatically route a query to the appropriate agent based on its description. This mimics a software team’s workflow – e.g. the planner breaks down work, the coder writes code, the tester reviews it. In fact, early adopters of Claude’s custom agents often set up teams with roles like *planner*, *code architect*, *tester/QA*, etc., showing the efficacy of dividing responsibilities.

Overall, the sub-agent feature is like having a **team of specialists** at your command, each ready to tackle a different aspect of development. We will harness this capability to address MapleUnity’s specific needs.

## Key Development Domains for Completing MapleUnity

To decide on the “dream team” of sub-agents, we first identify the major domains and pain points remaining in MapleUnity’s development. The goal is to cover **all critical areas without overloading on unnecessary roles**. Here are the primary areas requiring attention (derived from the project’s planned features):

* **Networking and Protocol Integration:** Implementing the MapleStory v83 network protocol (login, world/channel, game packets) so the Unity client can connect to a server. This includes handling encryption/cryptography if required and mapping server messages to game state updates. It’s a complex, low-level task distinct from gameplay logic.
* **NX Asset Pipeline Completion:** Finalizing support for MapleStory’s asset files (NX files). Earlier in development, **asset loading and metadata parsing (e.g. map tiles, object origins)** were a source of bugs, but through research and fixes the team has resolved most issues. The remaining tasks might include loading **all asset types** (skills animations, NPC sprites, item icons, audio, etc.) and fixing minor glitches (e.g. some transparent textures still not rendering). Ensuring the Unity client can seamlessly load every required image/sound from the NX data is essential for full fidelity.
* **Gameplay Systems & Mechanics:** Developing the advanced game mechanics that make MapleStory tick. The client already has basic movement and combat, but **skills and abilities** (e.g. mage spells, warrior skills), **NPC interactions and shops**, the **quest system** (quest log, progress tracking), and the **party system** are not yet implemented. These features involve both client-side logic (e.g. calculating damage for a skill, updating quest state) and corresponding UI (skill windows, dialogue boxes, etc.). They must also align with MapleStory’s original behavior, which may require referencing the old client or design documentation.
* **Unity Rendering and UI/UX:** For every new gameplay feature added, there’s a Unity front-end component. This includes **rendering sprites and effects** for skills, displaying **UI panels** (skill book, quest dialogs, shop interface), handling user input (e.g. key presses for skills or NPC interactions), and maintaining correct layering and camera behavior so the 2D world looks and feels like MapleStory. The MapleUnity project’s *GameView* layer is dedicated to these Unity-specific concerns, so new content must be integrated into this layer cleanly. Maintaining the polished MapleStory aesthetic and user experience in Unity is a non-trivial task.
* **Testing and Quality Assurance:** Given the project’s commitment to TDD, every new feature should come with unit tests and integration tests. Additionally, as systems become more complex, **regression testing** and debugging become crucial – e.g. verifying that adding networking doesn’t break offline play, or that a new quest system doesn’t introduce memory leaks or slow down the frame rate. Catching bugs early (perhaps by analyzing logs or using debug tools) and enforcing coding standards (ensuring logic remains separate from view, etc.) are vital to keep the codebase maintainable.

With these domains in mind, we can define a set of sub-agents, each a “specialist” focusing on one slice of the project. The team should be **comprehensive yet lean** – enough agents to cover all needs, but not so many that coordination becomes unwieldy. Based on the above, we propose **five key sub-agent roles** for MapleUnity, described below.

## Proposed Specialized Sub-Agents and Their Roles

### 1. **Project Planner & Architecture Agent**

**Role & Focus:** This agent acts as the **project manager and software architect** for MapleUnity. It plans development tasks, breaks high-level goals into actionable steps, and ensures the overall architecture stays consistent. Given MapleUnity’s layered design (GameLogic vs GameData vs GameView), the Architect agent will decide **which layer new code belongs in**, define interfaces between layers, and maintain adherence to the separation-of-concerns principle. It will also schedule the workflow: for example, coordinating that the Networking features are implemented in GameData layer first before GameLogic utilizes them. Essentially, this agent keeps the big picture in view – it’s responsible for **sprint planning, task delegation, and architectural guidance**.

**Why It’s Needed:** With many complex features to add, it’s easy to introduce messy code or lose sight of design principles. The Planner/Architect agent prevents that by guiding implementation to fit the intended pattern. It ensures that, for instance, the quest system logic goes into the platform-agnostic GameLogic (with proper interfaces), while UI for quests goes into GameView. It will also incorporate MapleUnity’s TDD workflow into planning – requiring that tasks start with tests and that sub-agents know to produce tests (it effectively enforces the development guidelines). By having this agent oversee the “who does what when,” the team of sub-agents will work in harmony and not step on each other’s toes. (In practice, this reflects how one might use a “planner” sub-agent as suggested by the community to outline steps, and even an “architect” agent to uphold structural integrity.)

**Example tasks:** The Planner agent might take a user story like “Add the Priest’s Heal skill to the game” and break it down into sub-tasks: e.g. *“Mechanics agent: implement Heal logic in GameLogic with healing formula and cooldown; Data agent: load Heal skill animation frames from NX and any data (e.g. skill damage metadata); UI agent: create a skill icon and hotkey for Heal, and visual effect when cast; QA agent: write tests for healing effect on characters.”* It defines these tasks and oversees their completion, reviewing if the integrated result meets the goal.

### 2. **MapleStory Gameplay Systems Agent**

**Role & Focus:** This is the **Game Mechanics Specialist**. It handles all **core gameplay logic development** for remaining features such as **skills and abilities, NPC behaviors, quests, and party mechanics**. Working primarily in the *GameLogic* layer (which is Unity-independent and fully unit-tested), this agent implements the rules and state changes that mirror MapleStory’s gameplay. For example, it will program how a skill like *“Fireball”* calculates damage and applies to monsters, how an NPC interaction triggers a quest acceptance, or how party members’ data is managed and shared. It will also ensure that **unit tests** are written for these mechanics, following TDD – e.g. test that a monster’s HP drops when hit by Fireball, that a quest’s state updates after completing objectives, etc.

**Why It’s Needed:** These gameplay features are at the heart of what makes the client functional and fun. They also require **domain knowledge of MapleStory**. The agent can be primed with knowledge (from design docs or the original client’s behavior) about how each system should work. By dedicating an agent to gameplay, we ensure a deep focus on **accuracy and correctness** of MapleStory’s rules. For instance, MapleStory has many idiosyncrasies (skill cooldowns, buff effects, quest item requirements) that the agent must get right. Isolating this work to a specialist means it won’t be distracted by UI or low-level networking details. The agent can even cross-reference the old C++ HeavenClient or MapleStory data to verify mechanics (since MapleUnity aims for feature parity with the v83 client).

**Example tasks:** Implementing *Skills and abilities* is a top priority (currently unimplemented). This agent would, say, implement the **Mage’s Teleport skill**: adding a method in GameLogic for teleport ability (checking MP cost, moving the player’s coordinates), writing tests for it, and ensuring the feature can be triggered via an interface (e.g. IInputProvider). Similarly, for **NPCs and shops**, the agent would create a system to handle talking to NPCs – perhaps a `ConversationManager` in GameLogic that holds dialogue state and a `ShopSystem` for buying/selling items – again with tests for transactions. **Quests** would involve creating Quest data structures, tracking quest progress, and triggering quest completion logic. All these tasks align with what MapleUnity listed as planned. By focusing solely on logic, this agent ensures the *rules* of MapleStory are implemented thoroughly and correctly, ready to be plugged into the front-end. (The Planner agent may coordinate with this agent to ensure each feature’s logic is done before UI or networking hooks are added.)

### 3. **Data Integration & Networking Agent**

**Role & Focus:** This agent is the **systems integrator**, responsible for external data and backend connectivity. There are two main realms for this agent: **asset pipeline** and **networking**. On the asset side, it will finalize **NX file loading** – making sure every sprite, tile, sound, and data blob needed by the game can be read from the MapleStory data files. MapleUnity already uses a library (NoLifeNx) for NX file reading, and much progress has been made (maps, tiles, and objects are loading after recent fixes). The agent will resolve any remaining asset issues (e.g. the **transparent textures bug** where some images appear blank, or ensuring *all* NPC and skill graphics are accessible). It may also optimize asset loading for performance, so that map transitions or asset-heavy scenes don’t lag the game.

The second (and larger) responsibility is implementing **network communication with a v83 server**. This involves writing the client-side networking code in the *GameData* layer (since networking is an external system). The agent will establish how the Unity client connects to the MapleStory server (likely HeavenMS or similar), handle login handshakes, and exchange packets for player movement, chat, combat, etc. It must implement the MapleStory protocol (which includes encryption, opcodes for different actions, etc.). The agent will likely create a **NetworkManager** or similar service that interfaces with GameLogic – for example, providing data about other players or monsters that the server sends.

**Why It’s Needed:** Networking is a specialized, complex domain—mixing low-level socket programming with knowledge of MapleStory’s packet structures. By assigning a dedicated agent, we ensure full attention to this without derailing the rest of the team. Likewise, asset loading requires careful handling of binary formats and metadata. Combining these under one agent is feasible because both are part of the *GameData layer* (external I/O concerns). This agent can handle all “data coming in and going out” of the client. Moreover, having the same agent on assets and network can be efficient: as the networking code will also need to load data (e.g. character data, item info from NX files to display when server says you got an item). A unified Data agent can ensure that the networking and asset systems work in concert (for example, verifying that item IDs from server correspond to the right item sprites from NX data).

**Example tasks:** Implementing **Networking (v83 server connection)** is explicitly on the roadmap. The Data Integration agent would tackle this by perhaps porting or referencing parts of the C++ client’s networking code (HeavenClient) into C# – e.g. using `System.Net.Sockets` or a Unity networking API to connect to the server, handling byte-level packet assembly. It would ensure that when the player moves or attacks, a packet is sent, and when a packet from server arrives (e.g. “monster died” or chat message), the game state updates accordingly. On the asset side, an example task could be: verifying that **all skill animations** are loadable – MapleStory has many skill effect images in the NX files. The agent might write a utility to bulk load every skill animation to ensure no format is unsupported, addressing any that fail. By completing these tasks, this agent enables the client to **fully populate the game world with content and connect that world to a live server**, which are critical steps toward a functioning MMO client.

### 4. **Unity UI & Experience Agent**

**Role & Focus:** This agent is the **Unity front-end specialist**, focusing on all **UI, graphics, and user experience** aspects of MapleUnity. Once the Gameplay agent and Data agent provide the logic and data, the UI agent brings it to life in Unity. This includes developing **Unity UI panels and controls** for things like the skills window, inventory expansions (for shops/trading), quest log interface, party interface, etc., in line with MapleStory’s look and feel. It will also handle **in-game rendering** for new features: for example, showing skill animations on screen (perhaps using Unity’s particle systems or sprite animations), rendering NPC dialogue boxes, and drawing quest indicators. Additionally, this agent deals with **input and interaction** from the player’s side – ensuring that if the user presses the “K” key to open the skills menu or clicks an NPC, the appropriate UI and logic trigger (wiring up Unity’s input system to the game logic events).

Another important aspect is maintaining the correct **visual layering and camera behavior**. MapleStory’s 2D maps have multiple layers (background, tiles, objects, characters, UI) that need proper draw order; MapleUnity’s recent fixes to sorting layers underscore this. The UI agent will ensure that as new elements (e.g. NPCs, effects) are added, they are assigned to the right sorting layers or UI canvases so nothing appears in front of or behind where it shouldn’t. It also will manage performance for rendering (e.g. not instantiating too many Unity objects unnecessarily, perhaps pooling sprites for animations, etc., to keep 60 FPS target).

**Why It’s Needed:** Even if the game logic is perfectly implemented, the project won’t feel like MapleStory until the user can see and interact with those features in a polished way. Unity UI development is a distinct skill – laying out canvases, handling responsive scaling, using the Unity Animator for sprite frames, etc. By dedicating an agent to it, we ensure the *GameView* layer gets the attention it needs. This agent can be configured with knowledge of Unity’s best practices and MapleStory’s art style. It also serves as a bridge between the pure code and the end-user experience, catching any mismatches (for example, if the GameLogic says an NPC dialog started, but the UI isn’t showing, this agent will troubleshoot why and fix the UI). Essentially, the UI/Experience agent **polishes the game** – making sure all the new systems have a user-friendly interface and the nostalgia of MapleStory’s visuals is preserved even in a new engine.

**Example tasks:** For the **NPCs and shops** feature, after the Gameplay agent creates the logic for buying and selling, the UI agent would design a **Shop interface** in Unity: perhaps a window that lists items and prices (using Unity UI components), with drag-and-drop or button controls to purchase, and hooking this up to the GameLogic (via an interface method like `AttemptPurchase(itemId)`). It would also manage showing NPC dialogue text in a pop-up dialogue box with the NPC’s portrait – requiring the agent to load the portrait image (with help of the Data agent) and render it on a UI canvas, possibly with typing text effect to mimic MapleStory’s dialogue style. For **skills**, this agent would create the **skills hotkey bar and skill window UI** (since MapleStory has a window listing all your skills by job). It would also animate skill usage: e.g., when the player casts a spell, the agent uses the sprite frames from the asset pipeline to play the animation in Unity at the correct position on screen, with appropriate flip (direction) and perhaps sound effect. By completing such tasks, the UI/Experience agent ensures that all behind-the-scenes work by other agents is visible and interactive for the player, ultimately delivering a cohesive game client.

### 5. **Testing & QA (TDD Enforcement) Agent**

**Role & Focus:** This agent is dedicated to **Quality Assurance, testing, and code review**. In MapleUnity’s context, think of it as the **TDD Advocate** – it ensures that for every new feature or bugfix, there are tests written *first* and that the code meets the project’s quality standards. It will write and run **unit tests and integration tests** for the features the other agents develop, catching regressions or logic errors. For example, if the Mechanics agent adds a new skill, the QA agent will create tests for that skill’s behavior (and likely would have insisted on the test being created before implementation per TDD). This agent will also perform code review tasks: examining the code produced by others for adherence to style and architecture guidelines (e.g. no Unity code inside GameLogic classes, proper naming conventions, etc.). It can suggest refactoring if needed to keep the codebase clean. Another facet is **bug-hunting**: using debug logs and runtime testing to find issues. MapleUnity has debug modes and logs for troubleshooting; the QA agent can analyze these or prompt the team to add logging around new features to validate they work correctly.

**Why It’s Needed:** With multiple agents working on different parts, a dedicated quality gatekeeper ensures nothing falls through the cracks. This is akin to having a strict QA engineer or a “bug detective” on the team. Since the project explicitly values TDD and maintainability, this agent’s role is crucial to uphold those values throughout the rapid development process. It helps avoid scenarios where an agent might implement something that inadvertently breaks an existing feature – the QA agent’s tests would catch it. It also saves time in the long run by preventing integration problems: e.g. if the Networking agent’s code is not thread-safe or has a performance issue, the QA agent can detect unusual behaviors (like frame drops or memory spikes in tests) and alert the team. Essentially, this agent **keeps quality high and knowledge shared**: by reviewing code, it might even produce documentation or summaries of how a new system works, ensuring future contributors (or agents) understand it.

**Example tasks:** Suppose the **quest system** is being added. The QA agent will write tests for quest progression: completing quest objectives should mark the quest done, rewarding the player appropriately, etc. It will run these tests (and all existing ones) after the Mechanics agent implements the quest logic to ensure everything passes. If a test fails, it will pinpoint the regression for the team to fix. Another example: after the Networking agent integrates server communication, the QA agent might conduct a simulated multiplayer test – perhaps using a test double for the server or a local server – to verify that the client stays in sync (e.g. two clients see the same world state). It will also keep an eye on performance metrics (there are performance tests listed in the project) and maybe run stress-tests like loading multiple maps rapidly to see if asset loading remains stable. Throughout all this, the QA agent enforces the **TDD cycle** (write failing test -> make it pass -> refactor) for every new code submission, effectively being the conscience of the project’s development process. In community setups, people often include a similar dedicated test/review agent because it significantly improves reliability.

## Conclusion and Next Steps

By assembling these five specialized sub-agents, we cover all critical aspects needed to complete the MapleUnity project while keeping the workload organized. Each agent has a clear purview – from high-level planning to low-level networking, from back-end logic to front-end polish, and the ever-important testing in between. **Claude Code’s sub-agents will collaborate much like a real development team**, where the planner breaks down tasks, the specialists build features in their domains, and the tester verifies quality, all coordinated towards the common goal of a **fully functional MapleStory client in Unity**.

With this “dream team” configured, the development can proceed in parallel and with expert attention on each front. Claude will automatically invoke the right agent for a given task (or we can explicitly prompt a specific agent), leveraging their separate contexts to avoid confusion and maximize efficiency. For example, as we work on networking, the main conversation can stay focused on gameplay design while the Networking agent handles packet details in the background. The end result is a streamlined workflow: **faster implementation of features, fewer bugs slipping through, and a codebase that remains clean and maintainable**.

Armed with this sub-agent team, the MapleUnity project is well-positioned to achieve its end goal. We can confidently tackle the remaining features – connecting to live servers, loading every asset, casting every skill, chatting with every NPC – knowing that each aspect has an expert agent on it. In short, Claude’s new sub-agents feature will be a game-changer for MapleUnity, helping turn the vision of a complete Unity MapleStory client into reality.&#x20;
