## MapleStory C++ Positioning System

**Coordinate System:** MapleStory’s engine uses a **top-left origin** for images, with Y increasing downward. The character’s world position corresponds to the **feet on the ground**. All body part images are essentially drawn relative to this base position (the feet). However, **attachment points** in the data define how parts connect, so there is extra offset logic beyond simply using sprite pivots.

**Sprite Origin and Attachments:** Each sprite in the NX data has an **“origin”** property giving the anchor point (in pixels from the image’s top-left). For example, the default body sprite’s origin might be `(19, 32)` in pixels (meaning the foot anchor is 19px from the left and at the bottom of a 32px-tall image). This origin effectively marks where the **character’s base position** (feet) will attach on that image. The NX also provides a **“map”** of attachment points (vectors) for each part. For the body, common points are **“navel”** and **“neck.”** In one frame, the body’s map might have: `neck = (-4, -32)`, `navel = (-6, -20)`. These are offsets *relative to the sprite’s origin* (negative Y means above the origin, since origin is at the foot). For the arm part, an example origin could be `(6, 8)` pixels (anchor near the shoulder), with map points like `navel = (-12, 2)` and `hand = (1, 5)`. Here the arm’s “navel” might denote the shoulder connection point (12px left of the arm’s origin, 2px below it) and “hand” the end of the arm (1px right, 5px down from origin).

**How C++ Uses These:** The original MapleStory client does **not** set sprite pivot points explicitly. Instead, it calculates **offsets at draw time** using those attachment coordinates (often via a structure like `BodyDrawInfo`). Essentially, **all parts are drawn at the character’s base position (feet)**, but with calculated offsets so their attachment points line up:

* The **body** itself is drawn such that its “navel” aligns to the base foot position. In C++, they compute a base point like `bodyPos = body.map["navel"]`. When drawing the body image, they subtract the body’s navel offset, so that point hits (0,0). For the default stance, this usually means the body’s feet end up at Y=0 (ground). (In our example, bodyPos = (-6,-20), and subtracting that moves the body 6px right and 20px down so the navel is at (0,0) – the feet then appear at Y≈0).

* **Other parts** use the body as reference. For most parts, the C++ client aligns the part’s “navel” to the body’s “navel.” For example, the code does: `shift = body_position - part.map["navel"]`. So if the arm’s “navel” is (-12,2) and body\_position (body’s navel) is (-6,-20), the arm’s shift becomes `( -6-(-12), -20-2 ) = (6, -22)` in pixels. Drawing the arm at that offset from the feet ensures the arm’s shoulder attaches exactly at the body’s navel point. The C++ `BodyDrawInfo` precomputes an **arm base position** like: `armPos = arm.map["hand"] - arm.map["navel"] + body.map["navel"]`. This gives the global coordinate of the hand, but more importantly they use the arm’s “navel” for alignment.

* The **head** is attached via the neck. C++ computes `headPos = body.map["neck"] - head.map["neck"]`. This offset ensures the head’s “neck” point coincides with the body’s neck point. So the head sprite is drawn shifted such that its neck anchor meets the body’s neck on screen. All head sub-parts (face, hair, ears) then use `headPos` as their base. For instance, face positioning uses `facePos = body.map["neck"] - head.map["neck"] + head.map["brow"]`. That means the face image’s “brow” point will align within the head (so eyes are correctly placed). In the C++ code, they actually draw the face with an additional offset: e.g. `faceshift = drawinfo.getfacepos()` and draw the face at `base + faceshift`. Hair is similar (using the “brow” point as well).

**Bottom line:** **Yes, all character parts are essentially positioned at the same base (the character’s root position), but there is additional positioning logic using those attachment offsets.** MapleStory’s engine effectively anchors everything at (0,0) (the feet), then *subtracts each sprite’s origin and alignment coordinates* to place it correctly. The parts are **not simply auto-aligned by their own pivots**; the game actively uses the **“navel/neck/hand” attachment points** to offset each sprite so it connects properly.

## Unity Implementation vs C++ Logic

In **MapleUnity**, the initial approach was to use Unity’s sprite pivots to mimic MapleStory’s origins. For example, reading the NX “origin” and converting it to a Unity pivot (Unity pivot is normalized from bottom-left). The intended formula was:

```csharp
pivot.x = origin.x / width  
pivot.y = 1.0f - (origin.y / height)  // Flip Y for Unity
```

This formula matches Maple’s top-left origin to Unity’s bottom-left coordinate system. If applied correctly, the body’s pivot would be at the feet, etc. In fact, an internal comment notes: *“MapleStory uses top-left origin, but Unity uses bottom-left. So we use top-left pivot (0,1) to match Maple’s coordinate system”*. The **C++ client did not literally set a pivot** on sprites; it always subtracts the origin from the draw position. Unity can achieve the same visual result either by setting the pivot or by manually positioning GameObjects.

**Issues Encountered:** The MapleUnity logs suggest that after some experimentation, they **changed the pivot calculation** (perhaps to `pivotY = origin.y / height` instead of `1.0f - origin.y/height`). This “fix” was likely misguided – it would **remove the Y flip**, causing Unity to treat the origin as if the coordinate were from the bottom. That would actually misalign the sprite vertically (essentially doubling the error). The persistent problems (body at head height, arms at feet, face too high) indicate the pivot/origin logic still doesn’t match MapleStory’s. For instance, if the body’s origin isn’t being applied correctly, the body sprite’s feet won’t sit at Y=0. Similarly, the head sprite needs to be offset above the body, but if Unity just places it at the base with a wrong pivot, it appears overlapping the body.

**Missing Positioning in Unity:** Currently, the Unity code creates separate `SpriteRenderer` objects for each layer (body, head, arm, etc.) all as children of a common parent at local (0,0). There is **no additional transform offset applied** when updating sprites (the code just assigns `renderer.sprite = ...` for body, head, face, etc. and leaves them at local (0,0)). This means Unity is relying **entirely on the sprite pivots** to position parts. If those pivots are wrong or if inter-part offsets aren’t accounted for, misalignment occurs. In the C++ engine, by contrast, the head and arms were shifted relative to the body’s position using the attachment points (neck, navel). Unity isn’t yet doing that.

**Verification vs C++:** We can cross-check Unity’s data with the C++ logic using the NX values. For example, in C++ the body’s “neck” point is used to place the head. In Unity, one would need to either: (a) set the head sprite’s pivot such that when placed at the same base position it naturally sits where the neck aligns (difficult since it requires pivot beyond the sprite’s bounds if the head’s neck is above the sprite’s bottom), or (b) position the head GameObject at an offset (0, some Y) relative to the body. Currently, Unity does neither – the head sprite was loaded via `LoadCharacterHead` without special pivot handling (it likely defaulted to top-left pivot), and it’s placed at (0,0). Thus the head appears down by the body’s side. The same goes for the arm: if the arm’s pivot isn’t at the shoulder, Unity will place it at (0,0) and it ends up near the feet. This matches the symptoms (left arm near legs, body at head level).

**Conclusion – All Parts at (0,0) + Pivot vs Additional Logic:** In theory, if every sprite’s pivot were **exactly set to the correct anchor point**, you *could* place all parts at the same (0,0) and they would line up. **However**, in practice MapleStory’s character uses **multiple attachment references**, not just one uniform origin. The **body** uses the foot as origin to the world, **head attaches to body’s neck**, **arms attach at the body’s navel/shoulder**, etc. The MapleUnity implementation needs to mirror that. That likely means either **computing offsets for child objects** (e.g. set `headRenderer.transform.localPosition = (0, neckOffsetY)`) or ensuring the pivot conversion uses those map points. The C++ code clearly shows that parts are positioned by subtracting their map coordinates relative to a base – effectively *additional positioning logic* on top of the sprite’s own origin.

In summary, **character parts are drawn at the same base position (0,0) in MapleStory, but not “magically” by pivots alone – the engine uses the origin and map attachment points to offset each part so they connect properly**. MapleUnity will need to incorporate those attachment offsets (either via correct pivot calculations for each part or by manual transform adjustments) to fix the misalignments. The head, for example, should be offset upward by the body’s neck distance; the arm should be shifted such that its shoulder (navel) meets the body, etc., if simply placing everything at (0,0) isn’t yielding the correct result.
