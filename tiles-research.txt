Got it. I’ll start by analyzing the C++ client’s tile rendering and sorting logic, focusing on how it calculates layer ordering and tile positioning. I’ll prioritize identifying any z-ordering properties like `z` or `zM`, and any special rules for edge tile variants. I’ll pay particular attention to the `Tile.cpp` and `MapTilesObjs.cpp` files, especially as they relate to map 100000000 (Henesys).

I’ll update you once I have a detailed breakdown of the relevant logic and insights.


## Layer Ordering Logic

The current sorting formula in Unity – using `(7 - layer) * 10000 + (-y)` – is a simplification that doesn’t match MapleStory’s actual depth ordering. In the official C++ client, each tile has explicit **depth values** (`z` and `zM`) from the data that determine draw order. Rather than using world Y position for tile sorting, the original client sorts by these depth fields. In MapleStory’s data (`.wz`), every tile image has a **“z” property** (its depth rank), and each tile placed in the map has a **“zM”** value (an additional map-level depth offset). The C++ client reads these and uses them as the primary key for sorting tiles.

### How the C++ Client Sorts Tiles

In the Journey/LibreMaple C++ code, tiles are inserted into a multimap keyed by their `z` value (obtained via `Tile::getz()`), and then drawn in ascending order of that key. This means tiles with lower depth values are drawn first (behind), and higher depth values drawn last (in front). Notably, the code doesn’t explicitly sort by Y at all – the layering is handled by the depth indices. The `Tile::getz()` likely combines the tile’s `zM` (map offset) and the tile image’s `z` (base depth) into one value. In our MapleUnity extractor, we already capture these fields (`TileData.Z` for image depth and `TileData.ZM` for map depth offset). We should leverage them for ordering:

* **Use `zM` and `z` for sorting:** Update the tile sorting logic to rank primarily by `TileData.ZM` and `TileData.Z` instead of using Y. In practice, MapleStory map designers use `z`/`zM` to ensure, for example, that grass edge tiles render above base dirt tiles even if they are on the same layer. We can construct a **composite sort key** reflecting the original behavior. For example:

  ```csharp
  // Pseudo-code for sort key
  int layerPriority = (7 - tile.Layer) * 100000;      // base: layer 0 gets highest priority
  int depthPriority = tile.ZM * 1000 + tile.Z * 100;  // combine map and image depth
  int yPriority     = tile.Y;                        // use Y as a tiebreaker (higher Y -> front)
  tile.SortOrder = layerPriority + depthPriority + yPriority;
  ```

  This scheme ensures that higher-layer (background) tiles start with a lower base value than lower-layer (foreground) tiles, preserving the overall layer ordering. Within the same layer, `tile.ZM` and `tile.Z` then sort tiles by the intended depth. We add `Y` (or `-Y`) only as a **tiebreaker** for cases where multiple tiles share the same depth values – this is not part of the original client’s algorithm (which would use insertion order for ties), but it helps avoid nondeterministic draw order in Unity. The key idea is that **depth values from the data drive the ordering, not purely the Y coordinate**.

* **Incorporate `zM` for cross-layer overlaps:** The `zM` field might allow certain tiles to render above others even if they belong to a “behind” layer. In practice, MapleStory’s tile layers are usually drawn strictly back-to-front, so a tile in layer 3 won’t normally appear over a tile in layer 2 unless intentionally designed that way. However, to be safe, our sorting should respect `zM` globally. (The HaCreator map editor, for instance, ensures all used zM values are unique across layers, hinting that the game merges layer drawing by these values.) This means if a layer has a tile with `zM=1`, it should render after all tiles with `zM=0` from any layer. The above composite key already handles this: we give `layer` a large weight so that no tile from a nominally “front” layer is accidentally behind a “back” layer tile. But within the same layerPriority group, `zM` will sort the tiles. For example, if layer 5 has a tile with `zM=1` and layer 4 has `zM=0`, both will get different base layerPriority, so layer 4’s tile (foreground layer) still comes later. This matches MapleStory’s behavior – tile layers generally don’t intermingle out of order. The crucial fix is **using the proper depth indices (z/zM)** to sort tiles on each layer, rather than a blanket Y-based sort.

* **Verify with data:** After implementing, log a few tiles’ sort keys (layer, zM, z, etc.) to ensure, for instance, Henesys’s grass edges have a higher depth key than the dirt ground tiles. In Henesys’s data (woodMarble set), we expect ground “bsc” tiles to have `z=0, zM=0` and grass edge “edU” tiles to maybe have `z=0, zM=1` or `z=1` (depending on how the WZ is set up). The MapleUnity extraction suggests many edge variants do carry a higher `zM` or `z`. Using these will naturally sort edges on top of bases, resolving the “half grass half stone” overlap issues.

### Layer Overlap Considerations

It’s worth noting that the original client’s layering is mostly fixed: layer 7 is the far background and layer 0 is the front-most tile layer. Tiles in layer 0 will always appear over tiles in layer 1, and so on. The `zM` depth offsets are mainly used **within a layer** to order tiles (and possibly to align with objects’ draw order). There isn’t evidence that a tile in layer 3 can ever surpass one in layer 2 just by `zM` alone – the engine still draws layer 2 after layer 3. Our strategy above preserves that hierarchy (by encoding layer into the sort key). If we discover cases where MapleStory does intermix tile rendering (which would be unusual), we can adjust, but most likely **ensuring correct intra-layer ordering** will fix the visual stacking problems.

## Edge Tile Alignment

With origins now correctly applied, most tiles in Henesys should line up, but the user still notices some edges “don’t sit right.” This is likely due to two things: **layering (depth)** and minor **position offsets**. We’ve addressed the layering – grass edges were previously sometimes drawn behind dirt tiles because all tiles were sorted only by Y. Once we sort by the proper depth, those edge tiles will render on top as intended, eliminating the obvious half-overlapping visuals.

If some edge tiles still appear misaligned (e.g. a thin gap or overlap persists), consider the following:

* **Verify no missing flip/rotation flags:** MapleStory’s map data for tiles does *not* typically include flip or rotation for terrain tiles (the `f` flag is present for some objects/life but tiles are placed as-is). Our extraction didn’t find any `f` property on tile nodes, so it’s safe to assume each tile’s orientation is correct. The edge variants (e.g. `slLU`, `slRD` for slopes, etc.) each have their own image in the tileset. We do not need to programmatically flip them – we just need to position them correctly.

* **Double-check origin usage for edges:** The pivot/origin fix was crucial (previously all origins were treated as (0,0)). Now that `SpriteLoader.GetOrigin()` returns the actual Vector2 origin, every tile – including edges – should be placed at the correct offset. Edges often have origin points that align them flush with adjacent tiles. For example, a top-edge tile (“edU”) might have an origin that positions it exactly at the top of the base tile below. If we still see a slight vertical or horizontal misalignment, it could be due to an off-by-one in our positioning math. Inspect the problematic edge tile’s origin values and compare to the expected placement:

  * Ensure we use the **same reference** as MapleStory: The NX origin is usually the bottom-left of the tile image’s bounding box. Our formula `localPosition.x = (centerX - origin.x)/100` and `y = (origin.y - centerY)/100` is meant to convert that into Unity coordinates. If an edge tile looks a bit high or low, try printing out `origin` vs the tile’s dimensions. It’s possible we need to round or floor the origin to the nearest pixel or adjust by 0.5 pixels to avoid gaps. For instance, if an edge’s origin.y is one pixel off, the grass might sit one pixel above where it meets the dirt. Maple’s rendering is pixel-perfect, so any float rounding issues in Unity could show a line.

  * One strategy is to **slightly nudge** edge tiles that are supposed to seamlessly connect. If a gap is visible, it might be due to Unity’s world-space scaling. Because we divide by 100 (assuming 100 px = 1 unit), a 1-pixel discrepancy can occur. We can test applying a tiny offset (like 0.01 units) to edges or adjust the Transparency Sort Axis (set it to Y=1 in Unity for top-down sort) to see if that removes the seam. However, these should be last resorts – first ensure the math is correct.

* **Z-order of slopes and corners:** Some sloped tiles (e.g., `slLU` “slope left up”) might extend into a neighboring tile’s space. MapleStory’s approach to these is to give them an appropriate `z` so they draw over the adjacent tile if needed. Check the `z` values for slope tiles in the tileset. If a slope tile that covers part of the tile above it isn’t drawn on top, confirm that its `z` value is higher. We should be reading and applying that already. If not, adjust the sorting key weighting (for example, increase the weight of `tile.Z` in the sort key if those differences are subtle).

In summary, **most alignment issues for edges will resolve once depth sorting is correct.** The grass-over-dirt “half tile” issue is a textbook case of depth ordering – the grass edge needs to render last. After fixing that, any remaining misalignment is likely sub-pixel positioning. We should systematically check a few edge tiles in Henesys:

* The top-edge grass (edU) on platforms – does it perfectly meet the dirt below? If there’s a gap, compare the Unity coordinate of the grass tile’s bottom edge to the dirt tile’s top edge. They should be equal. If not, adjust the calculation (it could be as simple as adding +0.5 pixel in world units to the Y if Unity is rounding down).

* The **sloped tiles** (like those half ramps in Henesys) – do they connect smoothly to flat ground? If the angle looks off or there’s overlap, ensure both pieces are at the correct positions. These might not be purely vertical alignments, but if origin is right they should naturally form a continuous slope.

* If certain edge pieces seem to protrude too far forward or back, that’s again likely a sorting matter (e.g., a side edge “enH1” might need to draw over a neighboring tile). In MapleStory data these are handled by `z` values (for instance, a tile that represents a vertical edge might have a higher depth so it overlaps the tile to its left/right).

## Testing on Henesys (100000000)

Henesys (map 100000000) will be our proving ground for these changes. After implementing the updated sorting logic and verifying edge placement, run the game and closely inspect each layer:

* **Layer 0 and 1 (woodMarble tileset):** These include the ground and platforms in Henesys. You should now see grass edging rendered on top of dirt. No ground tile should poke through the grass. Walk around and confirm that the player’s feet appear on the grass, not clipping through it (this ensures the grass tile isn’t accidentally too far in front – characters are usually drawn above tile layers 2 and below, but since Henesys’s grass is layer 0, it should be in front of the player unless backgrounds are involved. In MapleStory, usually tile layers 0-1 are **foreground terrain** that can cover the character’s feet).

* **Layer 2+ (if any in Henesys):** Henesys might not use all layers for terrain, but if there are, make sure no weird ordering – e.g., a tree tile in layer 3 with `zM=1` should not suddenly cover something in layer 2. If something looks off, we may need to revisit whether our layer weight is too large. Ideally, the visual result should match MapleStory: background elements stay behind, foreground elements stay in front.

Once Henesys looks “perfect,” we should test other maps to ensure the rules hold generally. Common areas to test:

* **Ellinia or Leafre (lots of sloped tiles and tall mushrooms)** – Check that slopes and vertical connectors align.
* **Maps with multiple tile layers** (e.g., some Kerning City maps have sewers under grates) – Verify that our layer sorting doesn’t need special cases.
* **Character occlusion** – Are there any tiles meant to be *above* the character (e.g., a tree canopy)? Those are usually done via the “front” flag on backgrounds or using tile layer 0. If Henesys has any tile on layer 0 that should cover the player, ensure it does. Conversely, tiles on layer 1 and beyond should not cover the player if they’re meant to be behind. MapleStory typically draws the character between certain layers (the Stage code draws characters after layer 2 by convention). We might not need to change anything here, but keep an eye out in case a tile is unintentionally covering the character sprite when it shouldn’t.

By focusing on **proper depth sorting and verifying edge-case tiles**, the rendering in Henesys should now closely mirror the official client. The user already noted it’s “much better now” – these changes will tackle the remaining layer order problems and edge alignment quirks. From there, we can iterate on any specific anomalies and then extend the solution to all maps.

**Sources:**

* MapleStory tile data structure (WZ): tile images include a depth “z” property and map tiles have an additional “zM” for ordering.
* MapleUnity Map extractor confirming `z` and `zM` are read for each tile.
* Journey (LibreMaple) client code inserting tiles sorted by `Tile::getz()` (depth) and drawing in that sorted order, rather than by Y position. This aligns the rendering order with the intended layering of the assets.
