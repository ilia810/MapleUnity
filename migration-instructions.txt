Great. I’ll create a detailed high-level design for rewriting the MapleStory client in Unity C# for PC, strictly adhering to Test Driven Development and Separation of Concerns principles, with clear interfaces. The gameplay and behavior will match the original client, and we’ll initially use an existing NX reader for assets.

I’ll break down the architecture, define key interfaces and layers, outline development stages, and explain how TDD will guide implementation. I’ll also recommend modular structures that ensure testability and clean boundaries.

I’ll let you know as soon as it’s ready for review.


# Design Plan: Rewriting the MapleStory Client in Unity (C#) with TDD and Clean Architecture

## Project Overview and Goals

We plan to **reimplement the MapleStory game client** (specifically the HeavenClient for MapleStory v83) in Unity using C#. The goal is to **replicate the original game’s features exactly** (no gameplay changes), targeting PC. This rewrite will adhere to **strict Test-Driven Development (TDD)** and **separation of concerns** principles. We will structure the code into clear modules/layers with well-defined interfaces, making the codebase maintainable and thoroughly unit-tested. MapleStory’s assets (maps, sprites, etc.) are stored in NX files (converted from official WZ files), and we will utilize an existing NX file reading library (e.g. **NoLifeNx**) to load game data. If necessary for our design principles, we can later port the NX loading functionality into C# as part of the Unity project, but initially we’ll treat it as an external dependency.

**Key objectives:**

* **Functional Parity:** The new Unity client should reproduce all features of the original client (same maps, monsters, items, UI, etc.), working with MapleStory v83 server logic (e.g. HeavenMS) on PC.
* **Clean Architecture:** Implement a layered architecture that separates core game logic, data handling, and Unity-specific presentation. Each layer/module addresses a distinct concern, which improves maintainability and testability.
* **Strict TDD Process:** Use TDD for all major components – write tests first, then implement code to pass the tests, ensuring **modular, bug-resistant code**. This approach inherently forces clear boundaries and separation between systems. Every feature or behavior will be specified by tests, leading to cleaner code and fewer regressions.
* **Clear Interfaces:** All interactions between systems (e.g. game logic ↔ input, logic ↔ rendering, logic ↔ data) will occur via well-defined interfaces or event messages. This decoupling allows each part to be developed and tested in isolation, and fosters a **single-responsibility** design for each class. (For example, the game logic layer won’t directly call UnityEngine APIs – it will signal what to display through interfaces, which the Unity layer implements. Likewise, Unity will send player input to the logic through an input interface, not by accessing logic state directly.)

By enforcing these principles, we aim for a Unity client that is easier to extend and modify without breaking existing features. As noted in one developer’s experience, **unit-test-driven code tends to be modular with clear boundaries and separation of concerns** between systems. Similarly, separating game functionalities (gameplay vs. UI vs. state management) makes the code more understandable and testable. The TDD approach may require more effort initially, but it prevents many bugs and regressions down the line and yields a cleaner architecture.

## High-Level Architecture

To achieve separation of concerns, we will organize the project into **three main layers** (or modules), following a common game architecture pattern:

* **1. Game Data Layer (Asset/Data Management):** Responsible for loading and providing game data and external services. This includes reading NX files for game assets (maps, items, etc.) and handling networking. It encapsulates low-level operations like file I/O and socket communication. The game logic will request data or be notified of events via interfaces in this layer, rather than reading files or sockets directly. For now, we will wrap the existing NX library behind a C# interface so the logic can fetch things like “Map layout for map ID X” or “Stats for item Y” without knowing how the data is loaded. Similarly, a network client (if connecting to a server) will live in this layer, emitting game events (e.g. monster spawn data) to the logic layer. This layer might also cover other external systems (audio playback could be considered here or in the visual layer, but we can abstract audio as a service).

* **2. Game Logic Layer (Core Gameplay):** This is the core of the application – the **model and gameplay rules**. It includes all game state, rules, and mechanics independent of any rendering or Unity engine specifics. Here we’ll have classes for the player character, monsters, maps, inventory, skills, etc., and systems for physics/collision, combat calculations, quest logic, etc. This layer is essentially an engine-agnostic simulation of MapleStory’s world. It will interact with the Data layer via interfaces (e.g. to load a map or send a packet) and expose state changes or events to the Visual layer (e.g. “character moved” or “monster died”). **No UnityEngine code will be in this layer** – this ensures it can be fully unit tested and run independent of the game engine. The logic layer will be updated each frame (e.g. an Update(deltaTime) method) by the Unity loop, but it won’t depend on `MonoBehaviour` callbacks internally. Keeping the game logic pure and isolated is crucial for TDD, as it lets us write fast unit tests for game rules without needing to run Unity. (In fact, in similar projects, \~90% of the code can reside in the gameplay logic, with Unity just handling rendering and input.)

* **3. Visual/Presentation Layer (Unity Frontend):** This layer contains all Unity-specific components: rendering, animation, Unity UI, and input handling. It’s essentially the **view** (and a bit of controller) in an MVC sense. This includes Unity `MonoBehaviour` scripts attached to GameObjects that display characters, monsters, map backgrounds, UI panels, etc. The visual layer listens to the game logic layer (through events or polling) and updates the Unity scene accordingly. For example, when the logic says a monster’s HP changed, a Unity UI element (health bar) will update; when a new map is loaded in logic, the visual layer will instantiate the appropriate map prefab/tiles and sprites. **Importantly, the visual layer does not contain gameplay decisions** – it doesn’t decide game outcomes, it only presents the current state and forwards player input. We will strive to keep the visual scripts as dumb as possible, often just forwarding events to the logic or playing a predetermined animation. This separation follows the Single Responsibility Principle and ensures that visual changes (like replacing a sprite or tweaking an animation) don’t affect game logic, and vice versa.

&#x20;*Architecture overview: the game logic layer is the heart of the system, isolated from Unity specifics. The Unity visual layer depends on the logic layer (for what to display), and the logic layer in turn depends on the data layer for assets and external inputs. Each layer interacts only with the one adjacent to it, enforcing a strict separation of concerns.*

Each layer will be accessed via clear interfaces. For instance, the game logic might call an `IMapDataProvider` interface (implemented in the Data layer) to get terrain information, or use an `INetworkClient` interface to send/receive messages. The Unity layer might implement an `IPlayerInput` interface that the logic consumes to get current input state, rather than logic querying Unity’s Input class directly. This way, **each layer can be tested or replaced independently**. If in the future we replace NX files with another format, we can swap out the Data layer implementation without touching game logic. Or if we want to run the logic in a server or console app (for testing), we could run it without the Unity visual layer at all. This design is aligned with “strict layered” architecture – objects only interact with the layer directly below/above, avoiding tight coupling or skipping layers.

### Core Game Logic Design

**Game World & Map:** At the center of the logic layer, we will have a `GameWorld` (or similar) class that holds the overall state: the current Map, the Player object, lists of NPCs/monsters in the map, projectiles, etc. The World will expose methods like `LoadMap(mapId)` which retrieves map data (through the Data layer interface) and populates the world with the appropriate objects (platforms, spawn points, NPC instances). The `Map` data structure will include the static collision geometry (footholds/platforms), portal locations, background layers info, etc., as obtained from NX. We will design classes like `MapObject` or `Entity` as base for anything that has a position in the map (player, mobs, NPCs, items on ground). Collision detection (e.g. checking if the player is on a platform or if a monster got hit by an attack) will be handled in the logic, likely with simple 2D bounding boxes or MapleStory’s specific rectangular foothold system.

**Player Character Logic:** A `Player` class (or set of classes) will represent the player’s state – position, velocity, stats (HP/MP, etc.), inventory, equipped items, current animation state (e.g. standing, walking, jumping), etc. Movement in MapleStory is a platformer style (left/right movement, jumping, climbing ladders, etc.), so we will implement physics appropriate to MapleStory (constant gravity, terminal velocity, etc.). For example, each update tick, if the player is not on a ladder or platform, we apply downward velocity (gravity) until landing on a platform or the ground. These mechanics will be unit tested: e.g., when a jump input is given, the Player’s vertical velocity should set to a jump impulse and then gravity brings them down; we’ll test that the player’s Y position eventually returns to the ground level based on the map’s platform data. By writing tests for movement physics and collision with platforms, we ensure the platforming behavior matches the original game. The Player logic will also handle input commands such as moving left/right (changing horizontal velocity), using a skill, or picking up an item (colliding with an item object). **All such actions will be triggered via methods that the input system or network calls**, not via reading Unity input directly in the logic. This means we might have something like `PlayerController` in the logic layer with methods like `MoveLeft(start/stop)`, `Jump()`, `Attack(skillId)`, etc., which the Unity input handler or AI or network can invoke. This separation allows us to unit-test these methods in isolation (e.g., call `Jump()` on the player and assert that the vertical velocity is set and state is “jumping”).

**NPCs and Monsters:** We will have classes for `Monster` and `NPC` (possibly inheriting from a common `Character` or `Entity` base for shared position/physics logic). These hold their stats and state. In an online setting, the server usually dictates monster movement and attacks, so the client logic might be minimal (just displaying and playing animations). However, to allow testing and possibly offline mode, we could implement basic monster AI or at least the ability to move and be attacked. We can structure monster behavior behind an interface (e.g. an `IMonsterAI` that could be a dummy for online or a simple AI for offline). In TDD style, we’d test scenarios like: when a player deals damage that exceeds a monster’s HP, the monster’s state changes to “dead” and a death event triggers (which would later inform visuals and possibly drop loot). We will ensure the monster’s state transitions (alive → dying → dead) are handled in logic and covered by tests.

**Combat and Skills:** MapleStory’s combat involves using skills that have certain effects (damage, projectiles, buffs). The logic will include a skill system that, given a skill usage input, computes the result: e.g. creating a hitbox or projectile, detecting which monsters are hit, and computing damage (likely using formulas and character stats). These computations can be unit tested by setting up a known scenario (player with X attack, monster with Y defense, use skill Z) and asserting the monster’s HP reduces by the expected amount. If the server authoritatively calculates damage, the client might just emulate for show; but we’ll implement it to mirror the original as closely as needed for consistency. We will also implement the concept of **cooldowns and buffs** in the logic layer, so these can be tested (e.g., using a skill twice within its cooldown should only affect once, etc.). The results of combat (HP changes, status effects) will be emitted as events to update the UI (HP bars) and play effects.

**Inventory, Items, and Quests:** The player’s inventory can be a class managing lists of items in different categories (equipment, consumables, etc.). The logic will enforce inventory limits and stacking, and provide methods to add/remove items. Tests will cover scenarios like picking up an item (should call PlayerInventory.Add and the item object is removed from world), using a potion (item count decreases and player HP increases accordingly), etc. Quests can be managed by a QuestManager class that tracks quest states; it can be updated when certain events happen (kill monster, collect item) and trigger completion when conditions are met. These are largely logic concerns and can be tested with fake events.

**Game State and Events:** The logic layer will likely make heavy use of **events** or callbacks to notify when something significant happens, such as *“MapLoaded”*, *“CharacterMoved”*, *“MonsterDied”*, *“InventoryChanged”*, etc. This event-driven design allows the visual/UI layer to simply subscribe to these events and respond, without the logic needing to know about any specific UI or visual code. For testing, we can subscribe dummy listeners or simply check state changes instead of actual events, but the event system is crucial for decoupling. For example, when the Player’s position changes, the logic can raise a `PositionChanged` event with the new coordinates; the Unity object representing the player will listen and update its transform.position accordingly each frame. Using events/interfaces in this way means the core logic doesn’t need to call `GameObject.transform` at all – it just fires an event or calls an interface method (e.g. an abstract `IGameView` interface could have methods like `SpawnMonster(monsterId, position)` that the Unity side implements). This aligns with the idea that **visuals should react to state, not contain state** – we keep state in the logic and only reflect it visually.

By designing the core gameplay as a self-contained module, we ensure it’s highly testable. We will create a **separate Unity Assembly Definition** for the logic layer (without UnityEngine references), so it can be compiled and run in a plain C# context (including in Edit Mode tests). The logic assembly will define interfaces for any outside interaction (input, data, network, etc.) that can be implemented by other assemblies. This way, our unit tests can provide *mock implementations* of these interfaces (e.g. a fake data provider that returns a hardcoded small map for testing movement, or a fake network client that simulates a monster spawn packet), to drive the logic in tests. This approach is recommended by many for making game code testable – treat things like rendering and input as pluggable components that can be swapped with fakes in tests. We won’t worry about any minor performance overhead of using interfaces and events; the clarity and testability benefits far outweigh that, and if needed we can optimize later.

### Data Layer and NX File Integration

The Data layer’s primary role now is to interface with the NX files that contain game data and assets. MapleStory’s NX files include everything from sprite frames to map layouts and string tables. We will use the existing NX reading library (likely a native DLL or .NET library) to load this data. To maintain our principles, we’ll **encapsulate the data access behind well-defined interfaces**: for example, an `IDataProvider` or specifically `IMapLoader`, `IItemDataManager`, etc.

Concretely, we might have a `GameDataProvider` class in this layer which implements interfaces like:

* `IMapLoader.GetMap(int mapId) -> MapData`
* `IItemData.GetItemTemplate(int itemId) -> ItemTemplate`
* `ICharacterData.GetSkillData(int skillId) -> SkillData`

The `MapData`, `ItemTemplate`, `SkillData` etc. would be plain C# classes or structs containing all info needed by the logic (extracted from NX). For example, `MapData` might have width/height, a list of platform coordinates, a list of monster spawn points (with mob ID and spawn interval), background images info, etc. The Data layer will use the NX library to actually read the bytes and convert to these data structures. By doing this translation at the boundary, the game logic never needs to understand NX file structure – it deals with easy-to-use classes. This is also beneficial for testing: we can make fake `MapData` by hand for tests (without needing actual NX files) and feed it to the logic.

In addition to static data, the Data layer will handle **assets** like textures and sounds. Likely, the NX files also contain the sprite images (or references to them). We have two choices: either extract all needed images at startup (which could be heavy), or load on demand. We might start simple: for a given map or character, load the required sprites from NX via the library, then convert them to Unity `Texture2D` or `Sprite` objects. We’ll use Unity’s API to create sprites at runtime from raw image data. Because this involves UnityEngine types, it might be partially in the Visual layer domain. A practical solution is to have the Data layer provide *raw data* (like byte arrays for images) or a file path, and the Visual layer actually constructs the Unity texture. Alternatively, we can treat the NX library as providing content that the Visual layer pulls when needed (e.g. when a monster is about to be shown, the visual code asks data layer for that monster’s frames). This detail can be refined, but the main point is to **keep asset loading asynchronous and decoupled**. We will ensure that loading large data (maps, many images) doesn’t freeze the game: perhaps load in background threads or gradually. In the interim, to keep things straightforward, we might load synchronously during scene transitions, but with an eye to refactoring to asynchronous if needed.

**Networking (if applicable):** The original client is meant to connect to a v83 server. In our Unity rewrite, networking can be integrated into the Data layer as well (because it’s an external system). We would implement an `INetworkClient` interface in this layer that the logic layer can use to send player actions to the server (e.g. `SendMove(position)` or `SendChat(message)`), and that can callback into the logic when data comes from the server. For instance, when a packet arrives indicating “monster spawned at X”, the network client would parse it and then call a method in the logic layer (or emit an event) like `OnMonsterSpawn(monsterId, position)`. The logic would then create a Monster in its state. By keeping this interaction to an interface, we can unit test the logic’s response to network events by simulating them (calling the interface’s callback with a test packet). We will likely use an existing C# networking library or .NET sockets for actual implementation, but hidden behind our interface. The interface also allows us to **run the game without a network (offline mode)** by substituting a stub that, for example, spawns monsters on its own or connects to a local pseudo-server. This flexibility is again gained by separation and TDD focus.

During initial development, we might not implement the full networking immediately – possibly start with a “single-player” mode where everything is local (for testing movement, combat, etc.). But the design will be ready to incorporate networking when needed without major refactor, due to the interface-driven separation. The HeavenClient C++ code had compile-time flags for using Asio networking; in our Unity version, we can simply not supply a network implementation until we want to test connectivity, all the while the logic and UI remain the same.

### Unity Visual & UI Layer Design

The Unity project will contain scenes, GameObjects, and MonoBehaviours that make up the presentation. Here’s how we will structure the Unity side:

**GameManager MonoBehaviour:** We will create a central `GameManager` (or similar) MonoBehaviour in the scene that is responsible for initializing the game and coordinating the layers. On startup, this manager will create instances of the Game Data layer classes (e.g. instantiate the `GameDataProvider` and possibly load NX indexes), and the Game Logic (instantiate the `GameWorld` or main logic controller). It will wire up the interfaces – for example, pass the `GameDataProvider` (which implements data interfaces) into the `GameWorld` so the logic can call data methods. The GameManager will also hold references to any singletons or service objects needed (like the NetworkClient if used, Input handler, etc.). Essentially, it’s part of the composition root that glues the pieces together. After initialization, the GameManager’s Update() loop will call the logic update: e.g. each frame do `gameWorld.Update(Time.deltaTime)` so the simulation progresses. We ensure this update call happens **before** rendering updates are applied (though Unity’s order of execution might not guarantee that easily, we might not need strict ordering if logic just computes positions and then we apply them to objects immediately or next frame).

**Player and Entity GameObjects:** For each type of visual entity, we’ll have a prefab or object in Unity. For example, a Player prefab that has a SpriteRenderer for the character, maybe some child GameObjects for effects, and a `PlayerView` MonoBehaviour script. The `PlayerView` script’s job is to link with the logic’s Player object. It might subscribe to events from the Player (like position or animation state changes) and apply them to the GameObject (setting transform position, playing an animation). It could also handle triggering certain Unity-specific things like particle effects on jump or footstep sound – but only in response to state from logic. Similarly, for monsters we have a `MonsterView` script that knows which Monster logic object it represents. We might manage this via an ID system or by having the logic spawn event provide a handle. One approach is: when logic wants to spawn a monster, it raises an event with monster data; the `GameManager` catches it and instantiates the Monster prefab in Unity, and then stores a mapping between that Monster logic object and the MonsterView (so each can find the other). The MonsterView then updates its SpriteRenderer based on the monster’s current HP or status (e.g. turn grey if stunned, etc.).

Crucially, **the MonoBehaviour scripts do not implement the game rules** – e.g., the MonsterView will not decide when the monster dies; it will listen for a “died” event from logic and then perhaps play a death animation and destroy the GameObject. This keeps Unity code simple. Most of Unity scripts will be about translating logic state to visuals (positions, animations, enabling/disabling objects) or capturing player inputs (keyboard/mouse) to pass to logic.

**Input Handling:** We will abstract Unity input so that it flows into logic through our interface. One way is to have an `InputController` MonoBehaviour that reads Unity’s Input system (or the newer Input System actions) each frame. Instead of directly moving the player, it will call something like `gameWorld.HandleInput(inputState)` or more specifically `player.OnInput(InputCommand.Jump)` in the logic. For example, in Update it can check `if (Input.GetKeyDown(KeyCode.Space)) then player.Jump()`. But to test this, we don’t want to rely on Unity’s Input. So we’ll likely design an `IInputProvider` interface with methods or properties like `IsLeftPressed`, `IsJumpPressed`, etc., that the logic can query or get events from. In production, `InputController` implements `IInputProvider` by returning Unity Input values. In tests, we can implement a FakeInputProvider that we control. Another approach is to push input into logic as events: e.g. when space is pressed, call `player.Jump()`. This is actually simpler to test (we just call the method in unit test). We will likely use this event approach for discrete actions (jump, attack, etc.) and maybe continuous input (movement) can be handled by setting a direction in logic each frame. Regardless, **the dependency will be inverted for testability**: the logic does not call `Input.GetKey` itself; instead, input state is supplied to it. This inversion is a form of dependency injection that TDD encourages (making the code receive what it needs from outside).

**UI Implementation:** MapleStory’s UI (inventory window, stats window, skill menu, etc.) can be implemented using Unity’s UI system (uGUI or Toolkit). Each UI element will have a script that interfaces with the logic. For example, an `InventoryPanel` MonoBehaviour will have references to some UI components (like item slot icons, etc.). It will subscribe to the Player’s inventory-changed events. When the logic adds or removes an item, the event provides the updated inventory state, and the UI script updates the icons and counts on screen. Conversely, if the player clicks an item in the UI (e.g. to use or drop it), the UI script will notify the logic (calling something like `player.UseItem(itemId)` or `player.DropItem(itemId)`). This two-way communication, again, is through clearly defined methods/events – the UI doesn’t manipulate the inventory data structure directly; it requests the logic to do so. This separation ensures that the consequences of actions (like using an item affecting HP, or dropping item removing it from inventory) are all handled in logic (which is tested), and the UI is just reflecting those changes.

We will create similar UI scripts for other interface elements: e.g. `StatusBar` for HP/MP bars (listens to player HP/MP and updates slider values), `ChatWindow` (displays chat messages that come via network/logic), etc. Each will be kept as simple as possible (formatting data for display). We can unit test some of the UI controller logic by invoking their public methods with sample data (though these are so closely tied to Unity UI elements that pure unit tests might be less useful – instead, we rely on the logic tests to ensure the data is correct, and we’ll do some play mode testing or manual testing to verify UI updates). If we want, we can use Unity’s integration test tools to simulate a bit of UI (for example, simulate a button click and verify it called a logic method), but these are more like high-level integration tests, not unit tests.

**Scene Organization:** We might have one main Unity scene that contains the persistent managers (GameManager, perhaps an AudioManager, etc.) and a Canvas for UI. The map and entities will be spawned under some GameObject hierarchy (e.g. a “MapRoot” object). We can load new maps by destroying the old map objects and instantiating new ones for the next map. The data for each map’s backgrounds/tiles might be quite large; to manage this, the Data layer could provide a list of background image assets and their positions which the visual layer iterates over to instantiate Sprites or Tilemaps. Because MapleStory’s maps are static, we could create Unity prefabs for each map, but that’s not feasible given the sheer number – better to generate from data at runtime. So our Map loader visual code might create GameObjects for each map layer (back, front, etc.) and add Sprites as needed. This can be optimized later (Unity 2D supports tilemaps which could be used if we convert the data properly).

**Audio:** The game has background music per map and sound effects. We will use Unity’s audio system to play these. The logic layer can decide when to play a sound (e.g. a sword swing sound when attacking, or a level-up sound). It will call an interface `IAudioPlayer.PlaySound(soundId)` for such events. The Unity side implements this by looking up an AudioClip (which could be loaded from NX or maybe we extract all sounds to a Resources folder for convenience) and playing it via AudioSource. We might keep an AudioManager object that holds a dictionary of soundIDs to AudioClips. For BGM, when a map is loaded, logic can emit an event “BGMChanged” with the track name, and the AudioManager will handle switching the background music. Testing audio isn’t crucial in unit tests (we can simply ensure the logic triggers the event), and we won’t focus heavily on it except to note it follows the same decoupling approach.

## Ensuring Test-Driven Development & Quality

From the outset, we will apply a **TDD workflow** to all core logic development. This means for each feature or module, we follow the *Red-Green-Refactor* cycle: **write a test first** (which fails red), implement just enough code to make it pass (green), and then refactor the code to improve structure while keeping tests green. Following this discipline guarantees we only add code when a test demands it, and the code will have immediate automated verification.

In practice, for each gameplay feature, our steps will resemble the following (adapted to game development):

1. **Write a Unit Test for the New Feature** – Define the expected behavior via a test before writing the feature code. For example, if implementing jumping, write a test that when `player.Jump()` is called, the player’s vertical velocity becomes positive and the player eventually lands back on the ground after some updates. The test focuses on the *interface and outcome* of the feature (what the rest of the system should see). This step forces us to design the API of our classes first, with clear intentions.
2. **Implement Minimal Code to Pass the Test** – Write the simplest possible code in the game logic to make the test pass. Continuing the jump example, implement `Player.Jump()` to set velocity and perhaps a flag. We won’t yet worry about fine-tuning gravity or animations – just enough so that the test expectation (e.g. final position on ground) is met. This keeps us focused on requirements and prevents over-engineering.
3. **Run and Verify (Play-test if needed) & Iterate** – Once the test is green, if the feature is something visible (like movement), we can run the game in Unity to subjectively verify it “feels” right (this is the stage of testing the feature in-game mentioned by some TDD game developers). We might find we need to adjust values or add nuance (e.g. maybe the jump height was off). Small tweaks might require updating tests or adding new ones (for different jump heights). We make iterative improvements, each time ensuring tests cover the changes. The suite of tests also gives us confidence to experiment with gameplay “find the fun” without inadvertently breaking earlier features.
4. **Refactor** – After confirming the feature works and tests are passing, we clean up the code. This might involve reorganizing logic, renaming methods, extracting interfaces if we coded something concretely, etc. Because tests are in place, we can safely refactor without fear – if we break something, a test will alert us. For example, if our jump code was copy-pasted in two places, we refactor to unify it in one method and run tests to ensure behavior stayed the same. This step ensures the design remains **clean and compliant with our architecture principles** after the flurry of making the test pass. In game TDD, this approach has been shown to maintain high velocity in development while keeping code quality high.

We will maintain a robust **unit test suite** covering the game logic layer extensively. Each class in the logic will have corresponding test classes (following a standard like one test class per game class) to exercise its behavior. Some examples: tests for Player movement, tests for inventory adding/removing items, tests for monster taking damage and dying, tests for map loading (e.g. given a sample MapData with certain platforms, ensure the World spawns the correct number of monsters, etc.). These tests will run in Unity’s Edit Mode test runner (or even outside Unity via a standard NUnit runner, since the logic assembly can be .NET Standard). We’ll also have a few **integration tests** (possibly Unity Play Mode tests) for interactions between layers – for instance, a test could instantiate a dummy DataProvider that feeds known values, run the GameWorld for a few ticks with a fake input sequence, and assert that the Visual layer’s stub received certain events (this might be simulated without actual rendering). This ensures our interfaces between layers are also working as expected.

To facilitate testing, we’ll use **dependency injection** patterns: either manually (passing interfaces into constructors) or with a lightweight framework if needed. For example, the GameWorld might have a constructor `GameWorld(IMapLoader mapLoader, IItemData itemData, IInputProvider input, INetworkClient netClient, IAudioPlayer audio)` so that in tests we can pass in fake or mock implementations easily. In Unity, the GameManager would pass the real implementations. This design was hinted at earlier and is critical for TDD – by coding against interfaces and not concretes, we can substitute test doubles to simulate various conditions (like simulate network messages or simulate certain input timing). We acknowledge that using many interfaces and indirection in a game might raise concerns about performance or complexity, but those concerns are manageable and the modularity is worth it. We’ll keep the interfaces focused and high-level to reduce coupling.

**Continuous testing and integration:** We will run the test suite frequently during development (ideally, set up continuous integration to run all tests on each push). This catches regressions immediately if a new change breaks something that used to work. The test suite also serves as a form of documentation of game behavior – one can read tests to understand how a feature is supposed to behave, which is useful for new contributors or when revisiting code after time. Our aim is to reach a point where most gameplay bugs are caught by tests early, and we rarely encounter unexpected issues while playing (TDD in Unity can indeed eliminate a vast majority of bugs if done thoroughly).

We will measure code coverage informally – focusing on critical systems. We don’t necessarily aim for 100% coverage (some glue code or trivial Unity boilerplate might not need tests), but we want all complex game logic to be covered. Particularly, physics and combat mechanics should be well-tested since bugs there could ruin gameplay. If certain tests become too brittle or hard to maintain, we’ll reconsider our approach (perhaps the design needs adjusting or the test might be more integration-level than unit). The guiding principle is to **test behaviors, not implementation details** – e.g., test that “using a potion increases HP” (outcome), not that “some private variable changed” (internal). This ensures we can refactor internals without rewriting tests as long as the external behavior stays consistent.

Throughout development, we will keep the design aligned with our separation of concerns. Whenever a new requirement comes (say, implementing a new MapleStory feature like party quests or pets), we will decide which layer it belongs to and extend that layer through its interface. For instance, pets might involve new visual objects following the player (visual layer) and some minor logic (pet item pickup logic in core). We would test and implement the pet logic in the core, and add the minimal support in visual (maybe a PetView following the player’s position). By following the patterns established, we can continue adding features without entangling the code. The strict layering ensures adding something in one area doesn’t inadvertently break others – e.g., UI changes won’t affect game logic since they’re separated. This modular approach **makes debugging easier too**: if a UI element is wrong, we know to look at the UI code; if a gameplay value is wrong, we check the logic, etc., because responsibilities are clearly separated.

In summary, our high-level design for rewriting the MapleStory client in Unity is to build a **cleanly layered architecture** with **core gameplay logic divorced from engine and UI code**, all developed with a **test-first mentality**. This will yield a Unity client that functions like the official one but is far more maintainable. By focusing on TDD and separation, we ensure that as the project grows to include all of MapleStory’s content, we can manage the complexity. The result will be a faithful MapleStory client where we can confidently refactor or extend features (say, to update to a newer version or add custom content) with minimal risk, thanks to the safety net of tests and the clarity of the code’s structure.

## Step-by-Step Implementation Plan

Finally, here is a proposed sequence of steps to implement this project, each step producing a testable increment of functionality:

**Step 1: Project Setup and Core Framework**

* **Unity Project & Version Control:** Initialize a new Unity project (ensure we use a compatible version for our target platform, PC). Set up a Git repository for version control. Add the **Unity Test Framework** package if not already present.
* **Assembly Definitions:** Create assembly definition files to separate our code into modules. For example, `GameLogic.asmdef` for the core logic (no UnityEngine dependency), `GameData.asmdef` for data layer (this may have to allow UnityEngine only if needed for loading assets, but ideally keep pure or use minimal engine), and `GameView.asmdef` for Unity-specific MonoBehaviours. Also create `GameLogic.Tests.asmdef` for the test assembly referencing GameLogic (and perhaps Data if needed). This enforces the boundaries: e.g., GameLogic assembly cannot accidentally call UnityEngine, and the GameView assembly can reference GameLogic to call its interfaces.
* **Import Dependencies:** Import or include the NX library in the project. If it’s a DLL, place it in Plugins. If source, maybe include it in a separate assembly (to keep it distinct). Also prepare any necessary data (we might need the NX files in a StreamingAssets folder or somewhere accessible at runtime).
* **Basic Data Interface:** Define a preliminary interface (or a few) in the GameLogic assembly for data access, e.g. `IMapLoader`, with a placeholder method like `MapData LoadMap(int mapId)`. Also define simple data classes (MapData, etc.) in GameLogic or a shared assembly that both logic and data can use. For now, the implementation can return stubbed data (e.g., a hardcoded small map for testing).
* **Hello World Test:** Write a simple test to verify the setup – for example, a test that creates a dummy implementation of `IMapLoader` (returning a small map with one platform), creates a `GameWorld` (which we haven’t written fully yet, just a stub that can accept the map), calls `LoadMap`, and asserts that the current map ID in GameWorld is set. This is mostly to ensure our test runner is working and the project structure is sound. Run the test in Unity’s Test Runner (Edit Mode) to confirm all is green. This step lays the groundwork for TDD in subsequent steps.

**Step 2: Implement Basic Map Loading (Data & Logic)**

* **Map Data Structures:** Expand the `MapData` class to include necessary info: dimensions, platform locations, etc. Also create classes for `Foothold` or `Platform` if needed to represent terrain.
* **NX Data Integration:** In the Data layer (likely in a GameData assembly or even within the logic assembly if we decide to include a small portion), write a `NxMapLoader` class that implements `IMapLoader`. Use the NX library to open an NX file (e.g., `Map.nx`) and retrieve map info. Start with something simple: for instance, get the map’s width/height and a list of footholds. (We can refine to full details later, but ensure we can pull some data.) If NX integration is complex, for this step you might bypass and create a **temporary fake data source** that uses an easier format (like a JSON or scriptable object for one test map) – the idea is to get map loading logic in place. We will later swap to actual NX.
* **GameWorld LoadMap:** Implement the logic in GameLogic layer for loading a map: e.g., a `GameWorld.LoadMap(int mapId)` method that calls the `IMapLoader` to get `MapData`, stores the current map, and possibly spawns static objects (no monsters yet, just terrain). Write unit tests first:

  * Test that after `LoadMap(id)`, the GameWorld’s current map property is not null and has the expected ID or attributes.
  * If we include footholds, test that the foothold list in GameWorld matches what the data provided.
  * Use a fake IMapLoader in tests that returns a known MapData (no NX needed for the test).
* **Visual Feedback:** In Unity, create a simple `MapView` MonoBehaviour that can display a map background or a ground tile for platforms (for now, maybe just a colored rectangle or line for ground). After `LoadMap` in logic, trigger the visual to draw something. This can be done via an event (GameWorld raises `MapLoaded`). Implement a temporary listener in the GameManager that instantiates a sprite or debug object representing the ground. This is mostly to manually verify in Play Mode that map loading works, though it’s not fully MapleStory-like yet. Keep it very simple at this stage (even a Debug.Log confirming load is fine).
* **Checkpoint:** At this stage, we have a basic ability to load a map’s data and some representation in Unity. The heavy MapleStory-specific details (multiple layers, etc.) can be filled in later once the structure is in place. Ensure all tests still pass.

**Step 3: Player Character Movement (Logic & Input)**

* **Player Logic Class:** Create a `Player` class in GameLogic with properties like `Position` (Vector2), `Velocity`, maybe `IsJumping` flags, etc. Also give it methods to respond to input: `MoveLeft(bool on)`, `MoveRight(bool on)`, `Jump()`, etc. Initially implement basic horizontal movement: when left is on, set horizontal velocity = -speed; when off, zero it (similarly for right). For jump, if not already jumping, set vertical velocity = jumpSpeed. Gravity will be handled in an update step.
* **Physics Update:** Add a method `Player.UpdatePhysics(deltaTime, MapData)` that updates the position based on velocity, applies gravity, and checks collisions with the map’s platforms. MapleStory’s physics is not too complex: constant gravity, and the player stands on the highest platform below them. Implement a simple collision: if after moving downwards the player’s y would go below the ground (or a platform directly below), clamp y to platform height and set vertical velocity to 0 (landing). We might need to iterate if velocity is large, but since MapleStory movement is relatively slow, a simple integration may suffice.
* **Unit Tests for Movement:** Write several tests for Player:

  * *Standing Still:* If no input, after update, position should remain the same (gravity might cause a drop until hitting ground – so set initial position on ground to test this).
  * *Walking:* Simulate holding right input for a few frames: call `MoveRight(true)`, then call `UpdatePhysics(deltaTime)` a few times, then `MoveRight(false)`. Check that the X position increased appropriately and velocity is zero after stopping. Use a small deltaTime (or loop many small steps) to simulate continuous movement.
  * *Jumping:* Place player on ground in a map with no ceiling, call `Jump()`, then call UpdatePhysics repeatedly until velocity in Y becomes zero or negative (peak reached) and player lands. Assert that the player’s Y position at peak is higher than start, and after enough time, the player is back to the same ground Y (within tolerance).
  * *Platform Collision:* If your MapData has a platform above ground, set player under it and give a large jump velocity that would cross the platform height. UpdatePhysics and ensure the player stops at the platform height instead of teleporting through. (This test might require a specific configuration of MapData – you can create one with a platform at a certain Y).
    These tests solidify the correctness of movement physics. TDD will guide adjustments – for example, you might realize you need to track whether the jump key is still held for some jump mods or to prevent double jump; you then adjust accordingly with tests.
* **Integrate Input (Unity):** Implement the `IInputProvider` or similar mechanism. For now, you can have GameWorld hold an `IInputProvider` that it queries each update or triggers methods on Player. Alternatively, simpler: in GameWorld.Update(), call something like `player.UpdateInput(inputProvider)` which internally calls Jump/Move based on current keys. Implement a Unity `KeyboardInput` class that reads `Input.GetKey` for arrows/space. In GameManager.Update(), before calling gameWorld.Update(), update the input state.
* **Visual Representation:** Create a basic Player sprite (a placeholder rectangle or a MapleStory character sprite if available). Attach a `PlayerView` MonoBehaviour that every frame reads the Player’s logic position and sets the GameObject’s transform.position accordingly. Also handle flipping sprite based on direction (if moving left vs right). No animations yet for simplicity. Verify in Play Mode that you can move the character with arrow keys and jump on platforms. The motion should correspond to the logic (the Unity object is just following). If something is off (e.g. collision not working), write a test to capture it, fix logic, then verify again.
* **Checkpoint:** At this point, we have a controllable character in a simple map. The core movement logic is tested and separated from Unity. We can move on to more gameplay aspects.

**Step 4: Interactions and Basic Combat**

* **Monsters Spawning:** Extend `GameWorld.LoadMap` to also instantiate monster objects in the logic. The MapData might contain monster spawn points and mob IDs. For initial testing, we can manually inject a monster into the world. Create a `Monster` class with at least: position, HP, and a reference to its monster template (stats like maxHP, damage, etc., which would come from data). Write logic for monster behavior minimal – maybe static or pacing left-right. For now, to focus on combat, monsters can be stationary targets.
* **Combat Logic:** Implement a way for the player to attack. MapleStory is 2D, so typically an attack hits targets in a certain range in front of the player. We can simulate a very simplified version: when the player attacks (say we trigger `Player.Attack()` on input), have the logic check all monsters in the world within a certain X range of the player’s position and apply damage. Damage calculation can be trivial for now (constant or based on a stat). Reduce monster HP and if it reaches 0, mark monster as dead and raise a `MonsterDied` event. Also possibly create a `DroppedItem` object in logic if we want to simulate item drops.
* **Unit Tests for Combat:**

  * Set up a test world with one monster at a known position and player at some position. Simulate an attack input and ensure the monster’s HP decreases or it dies.
  * Test that attacking out of range does not affect the monster (to verify range logic).
  * Test that a monster’s death triggers the appropriate event or state change (e.g., `IsDead` flag true, and maybe that a drop was created in world’s item list).
  * If we implement multiple attack types (e.g. skills), we would write tests for those as well, but initially one basic attack is fine.
* **Visual Feedback:** Create a Monster prefab with a `MonsterView` script that, similar to PlayerView, updates its position from logic and perhaps listens for a death event to play an animation or destroy itself. Also give the player a simple attack animation or effect: e.g., when attack input is pressed, play an animation (could be a single sprite change or a hand swing). In logic, when an attack happens and hits, raise an event so we can spawn a visual effect (like a hit flash or damage text). For now, we can print to console or flash the monster sprite (change color) to signify a hit. Ensure that when a monster “dies” in logic, the MonsterView destroys the GameObject or plays a death animation then destroys. Verify in Play Mode that you can attack the monster and it disappears when HP <= 0.
* **Continue TDD for Edge Cases:** Add tests for things like: monster HP not dropping below 0, player cannot attack if in mid-air (if we enforce that), etc., as needed by game design. We mirror MapleStory rules as much as known – e.g., MapleStory might allow attacking in air for some classes, but we can keep it simple unless needed.
* Now the core gameplay loop (move, jump, attack, kill monsters) is coming together, all backed by tests.

**Step 5: Inventory and Item Pickup**

* **Inventory System:** Create an `Inventory` class in logic to hold Item objects. MapleStory has multiple inventory tabs, but we can simplify initially to one list or a dictionary by item type. Implement methods like `AddItem(itemId, quantity)`, `RemoveItem(itemId, quantity)`, `HasItem(itemId)`, etc. Write tests:

  * Adding an item increases count or adds entry;
  * Removing beyond what’s owned fails or clamps;
  * Picking up an item from ground calls AddItem and removes the ground item object.
* **Item Drops:** When a monster dies, our logic already could be creating a `DroppedItem` object in the world. Implement the `DroppedItem` class with an ID and position. In GameWorld’s update, check if player is near a DroppedItem (collision), and if so, remove it from world and add to inventory (and raise an event like `ItemPickedUp`). Test this: simulate a world with a Drop at position X and player moving over it, call an update or a specific pickup method, and assert that the drop is removed and inventory has the item.
* **Use Items:** Implement usage for at least one type of item, e.g. healing potions. That means an item should have an effect – which might be defined in data (NX likely has info about what each item does). For simplicity, define an item type for potion that restores e.g. 50 HP. When `UseItem(itemId)` is called on player (via input or UI), logic checks inventory (if item exists), reduces quantity, and applies the effect (increase player HP up to max). Write a test for using a potion: set player HP to some low value, give potion in inventory, call UseItem, assert HP increased and item count decreased. Also test boundary (HP doesn’t go above max, or using item with none in inventory does nothing).
* **UI Integration:** Create a basic Inventory UI in Unity – perhaps a simple panel that lists item names or icons. When `ItemPickedUp` event fires, update the UI (e.g., add an icon). This could be as simple as a text list for now (“1x \[ItemName]”). Implement clicking on an item (maybe each item line is a button) to use it: that button’s onClick calls a function in a UI script which then calls `player.UseItem(itemId)` in logic. After use, the logic event for inventory change triggers the UI to update the count. We test this integration manually in play mode (or write a small integration test simulating the call).
* **Checkpoint:** Inventory is functional with a basic UI. We now have the core loops: combat and item rewards.

**Step 6: Expand Features and Content**
At this stage, the fundamentals are in place. Now we proceed to extend the game to match MapleStory features, always using our TDD + SoC approach:

* **More Player Abilities:** Implement other actions like crouching, climbing ladders/ropes (MapleStory has ladder climbing physics), or multiple skills. Each time, write tests for the behavior (e.g., climbing: test that when at ladder and up key is pressed, gravity stops and y moves up). Add states to Player as needed (e.g., an enum for current action state). Ensure logic controls when these states can switch (tested via unit tests for state transitions).
* **UI Enhancements:** Build out the UI to resemble MapleStory – health/mana bar, experience bar, skill menu, etc. Connect these to logic (HP/MP events update the bars, XP event updates the exp bar, etc.). Test logic for leveling up: if exp >= threshold, increase level, raise an event. UI just displays current exp/level. We don’t necessarily need unit tests for the UI rendering, but we should have tests for the exp/level logic.
* **Multiple Maps & Portals:** If MapleStory has portals between maps, implement portal logic: when player touches a portal trigger in logic, call `LoadMap` for the target map (via Data layer to get new MapData). Test that state resets accordingly (player position set to new spawn point, etc.). In Unity, possibly trigger a scene load or just reuse the same scene with new data (prefer latter to avoid reloading everything – we can destroy old map objects and instantiate new ones).
* **Networking Integration:** Introduce the real NetworkClient implementation and test connectivity with a server (HeavenMS or similar). This will be an iterative process:

  * Start by implementing packet handling for a few essential messages (map load/character spawn, movement, attack, damage, etc.).
  * Use TDD at a smaller scale: perhaps create a PacketHandler class and write tests that given a raw packet byte array, it produces the correct method calls or data output. We likely need to use or implement MapleStory’s packet structure (maybe HeavenClient’s code or HeavenMS repo can guide us).
  * Then integrate: when connected, instead of our local monster spawns or damage calculations, we might defer to server. This could mean disabling some logic when in online mode or reconciling the two. Possibly, we consider two modes: offline (client-side mobs) vs online (server authority). Since the goal is a client for v83 servers, ultimately we want to sync with server. That entails trusting server for monster positions and HP. We may adjust our design: e.g., logic layer will have a flag for “authoritative server” where certain subsystems (monster AI, damage calc) are either turned off or just used for prediction. This is an advanced networking concern beyond initial scope, but worth planning. However, because we used interfaces, much of this can be handled by substituting where data comes from. For instance, instead of logic internally spawning monsters, in networked mode the NetworkClient would instruct logic to spawn them (so we won’t call `SpawnMonster` in LoadMap unless in offline mode).
  * Test the integration by running against a known server and verifying movement, chat, etc., works. This is more of a QA test than unit. We ensure not to break our tested logic – likely only minor adjustments needed if any.
* **Asset Pipeline Refinement:** If not done earlier, optimize asset handling. Perhaps implement caching of sprites (don’t reload the same sprite repeatedly for multiple monsters of same type). Possibly port the NX reading fully to C# for easier use in Unity (if the existing lib is cumbersome via P/Invoke). This can be done gradually, replacing calls in Data layer with new code, guided by tests to ensure the output data remains the same.
* **Performance Tuning:** With more content, we should profile and ensure the game runs smoothly. If the interface abstraction introduced overhead, profile it (likely negligible relative to rendering and Unity overhead). If any system is slow (e.g., loading a big map causes a hitch), consider background loading or splitting the work over frames. But do not prematurely optimize – only do this if tests and usage show a need.
* **Polishing & Edge Cases:** Add tests for any bug fixes or edge behaviors discovered (e.g., what happens if the player jumps at map boundaries, or if two players in multiplayer?). While multiplayer beyond one client is out of scope, we might simulate another player as part of networking (the server would send other characters’ positions, which our visual layer would display as “ghosts” since logic is mainly single-player oriented). We ensure our design can handle multiple characters by possibly extending logic to have a list of Characters (one controlled locally, others updated via network). This could be an extension where each character is an object and input is only applied to the local one. It’s a complexity but doable with our flexible design.

Throughout these steps, we maintain **discipline in testing and separation**. If at any point we find ourselves about to write a chunk of code in a Unity MonoBehaviour that contains logic, we stop and consider moving it to the logic layer. Unity code should ideally just call a logic function or set a value. This guideline keeps us on track so that the majority of our code remains in the easily testable core.

Finally, as features complete, we will have a comprehensive test suite and a working game. New developers or team members can confidently make changes or add content because the tests will catch if anything breaks a core feature. The design’s clear interfaces also mean someone can work on, say, the rendering optimization without fear of altering game rules, or swap out how data is loaded (perhaps using a different file format) by just writing a new Data layer module. This modularity is the payoff of the strict separation of concerns approach – it might require more upfront design and careful coding, but it results in a far more robust and maintainable MapleStory client.

**Step 7: Testing & QA**

* Before finalizing, write additional **integration tests** in Unity’s Play Mode for crucial end-to-end scenarios. For example, a play mode test could instantiate the GameManager, simulate a sequence of inputs (perhaps by setting the InputProvider’s state over several frames), and use `Assert` to check that expected game state outcomes occur (like the player’s position or inventory). Unity allows some automated play mode testing with `UnityTest` coroutines which we can use to wait a few frames.
* Perform manual testing as well, playing through as a user would: kill monsters, change maps, use items, etc., to catch any issues not covered by unit tests (visual glitches, timing issues, etc.). Each time a bug is found, write a unit test reproducing the underlying logic error (if it’s in logic) and fix it, or adjust the Unity side accordingly while keeping logic intact.
* Review code with the team (if applicable) to ensure it follows the intended architecture. The clear separation into assemblies and interfaces should make the code structure self-evident. If any dependency rule was accidentally violated (e.g., a logic class directly using a UnityEngine type), refactor it now (tests will help ensure behavior stays same).
* Update documentation (like a README) to describe how the system is organized and how to run tests, load NX files, etc. This helps future maintenance and open-source contributors if any.

By following these steps, we incrementally build up the Unity MapleStory client, **validating each piece with tests** before moving on. The end result will be the “exact same game as the original” from the player’s perspective, but under the hood it will be running on a modern, well-architected codebase. Each concern (data loading, game rules, rendering, input) is cleanly separated, which not only aids testing but also makes future changes safer. For example, if later we decide to integrate a new rendering technique or switch input systems, we can do so by modifying the Visual layer without touching game logic. Or if we update to use actual WZ files instead of NX, we’d write a new data provider and the logic wouldn’t even notice the difference.

This design and process might seem thorough, but it’s what will give us confidence that the complex MapleStory client (with all its RPG systems and content) can be maintained and expanded by our team. It transforms a traditionally tricky genre (MMORPG client) into a set of manageable, testable components. As one developer insightfully noted, *“Test first development focuses your efforts where they are needed most, on defining and then implementing the functionality... as seen by the rest of the system.”* By defining our expectations upfront (via tests and interfaces), we ensure a clear, principled rewrite that will serve players well and be a joy for developers to work on.

Overall, this rewrite project is not just about porting code to C#; it’s about **improving the code quality and structure** dramatically while preserving game fidelity. With Unity’s engine capabilities for rendering and our rigorous TDD approach for logic, the new client will achieve the same MapleStory feel and functionality, but be far more robust under the hood.
