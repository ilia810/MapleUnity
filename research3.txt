# MapleUnity Object Origin Misalignment – Research Findings

## 1. Origin Storage for Map **Objects** in NX Files

In the MapleStory NX data (e.g. *Map.nx*), each map object’s sprite has an **origin point stored with its image frame** – typically as a 2D vector (x,y) under that frame’s canvas node. It is **not** stored at a high-level container like the `.img` or category node. For example, in the Henesys guide sign data (`Obj/guide.img`): the “post” sprite’s origin is defined in the frame **`0`** node itself. The NX structure (as seen in a WZ XML dump) shows:

* **Path:** `Obj/guide.img/common/post/0`
  **Origin:** `<vector name="origin" x="91" y="55"/>` (this is the origin of the sprite, in pixels).

This indicates the guide sign’s sprite is meant to be anchored at (91,55) within its 182×111 image (approximately its bottom-center). All other map objects follow a similar pattern: each frame’s canvas carries its own origin. For instance, in `Obj/houseGS.img/house9/basic/1` (a house object), the frame’s origin is stored with that frame’s image. The original MapleStory client uses these origin vectors uniformly for all sprites – when drawing an object, it subtracts the sprite’s origin from the object’s map coordinate so that the defined point aligns to the game world. There is no separate “object anchor” elsewhere; the origin is part of the object’s frame data.

**Why our current code misses it:** The Unity loader’s `GetOrigin` logic isn’t retrieving this origin for objects, likely because it’s looking at the wrong node. In NX, the object’s origin lives on the actual image node (the frame canvas). Our debug logs showed that for objects like *houseGS*, *guide*, and *signboard*, the code always fell back to `(0,0)` – meaning it never found the `origin` field. This suggests the loader might be stopping at a container node or a frame list node that doesn’t have the origin, instead of the image canvas node that does. For example, if the code is inspecting the parent folder (e.g. “post” or “basic”) or an intermediate frame node, it would not see the origin (which is inside that frame’s data). In the guide sign case, the origin isn’t at the `common` or `post` level – it’s inside the **“0”** frame node. Thus, the correct level to retrieve is the frame itself. Our Unity loader needs to ensure it’s querying the frame’s canvas node (or the image node containing the `origin` property) for objects, just as it does for tiles.

## 2. Origin Storage for **Tiles** and Why It Works

Map tiles also store an origin for each tile image, and our loader has been successfully retrieving those. In the NX data under `Map/Tile/...`, each tile’s canvas node has an origin vector. For example, in the *woodMarble* tileset:

* **Path:** `Tile/woodMarble.img/edD/1`
  **Origin:** `<vector name="origin" x="24" y="0"/>` (for that tile image, roughly centered width-wise).

Another tile example: `Tile/logMarble.img/enV0/0` (an end-piece tile) has origin `(28,0)` in a 28×61 image, meaning the origin is at the bottom-right of that tile (so it aligns properly with adjacent pieces). In general, ground tiles often have origin (0,0) if they align at the top-left, while slope/edge tiles have non-zero origins to position them correctly relative to other tiles. Our debug output confirms the Unity loader found origins for tiles such as `woodMarble.img/edD/1 → (25,0)` and `.../enH0/3 → (90,91)` (the latter being a large tile with a custom anchor). The reason the **tile origins load correctly** is that our code is effectively grabbing the image node that contains the `origin`. Tiles are organized with a simpler hierarchy (Tileset.img -> category -> frame), so our search (including checking the node and its parent) manages to find the `origin` field. In the NX data, the tile’s frame node often *is* the canvas node containing `origin`, or our loader correctly drills down into it. Thus, `SpriteLoader.GetOrigin` is hitting the right spot for tiles – e.g. finding an `origin` child on the tile’s frame node or its parent.

In summary, **both tiles and objects store their origin in the same way – as an `origin` property of each image frame**. The data itself is consistent. The disparity in our Unity implementation arises from how we traverse the NX structure for objects versus tiles, not from a fundamental data format difference.

## 3. NX File Structure Differences (Obj vs Tile)

While the concept of origin storage is the same, there are structural nuances between *Map/Tile* and *Map/Obj* data that could affect our loader:

* **Nesting/Path Depth:** Tilesets have a shallow structure: e.g. `Tile/<Tileset>.img/<variant>/<frame>`. Many tilesets have straightforward numeric frame nodes under category folders (or even directly under the `.img`). Objects, on the other hand, often have extra layers: `Obj/<Object>.img/<subfolder>/<sub-subfolder>/.../<frame>`. For example, a sign object might be `Obj/guide.img/common/post/0`, and a house might be `Obj/houseGS.img/house9/basic/1`. The Unity loader must navigate these extra levels. Our current implementation does try parent and grandparent for an `origin`, but the debug suggests we might be **checking the wrong levels**. It logged searching on nodes named “0”, “1” etc., which are the frame indices, rather than the actual canvas containing the origin. It’s possible that for objects, the loader either went one level too deep (into a raw image byte node without reading its properties) or not deep enough (stopping at an intermediate folder). The extra nesting means we need to be careful to grab the **frame’s data node**. In essence, tiles and objects use the same origin field, but objects’ origins might appear “missing” if we don’t drill down to the final canvas node.

* **Single-frame vs Multi-frame handling:** Some objects (and many tiles) consist of a single frame. In the WZ data, a single-frame image is still stored with an `origin`, but sometimes the structure can omit an extra numeric folder. (For instance, a static object part might be directly under a name, instead of under a “0” folder – though in practice Maple’s .img format often still uses a “0” child even for one-frame components.) If the NX library simplified single-frame nodes, the `origin` could conceivably be attached to a parent node. Our Unity code’s strategy of checking parent and grandparent might have been to account for such cases. However, based on MapleStory data we’ve inspected, even single-frame objects like certain signboard variants have an explicit frame node containing the origin. So the key is still to retrieve the correct node that has the `origin` field. There is no evidence that Maple objects store a shared origin at a higher-level node (each frame lists its own, even if they end up identical across frames). Thus, the **same GetOrigin logic can be used** for objects, but it must target the frame’s node properly.

* **NX Library quirks:** It’s worth noting that the NX data is likely being accessed via a library (NoLifeNx or similar). This library might represent the image frame differently for objects. For example, it might automatically merge the canvas node so that the `origin` is available as a property rather than a child node. Our debug scripts found that `RealNxNode` sometimes converts `origin` into a `Vector2` value internally. If that’s the case, our `SpriteLoader.GetOrigin` should perhaps call something like `node.GetValue<Point>()` or inspect the node’s value rather than only looking for an `["origin"]` child. The current code only checks `node["origin"]` and then ascends, which could miss origins if the library doesn’t expose them as a child. This could explain why all object origins came through as `(0,0)` – the code never actually fetched the internal origin. By contrast, maybe tile nodes were structured in a way where `origin` still appeared as a child (or the loader ended up calling `GetOrigin` on a parent that still had the origin field). In short, the NX file format itself treats origins uniformly, but our approach may need to be adjusted for how the NX API presents object frames versus tile frames.

## 4. Comparing C++ Client Loading Process

The original MapleStory client (C++), and open-source implementations of it, do not distinguish between tiles and objects when loading sprite origins – they read whatever `origin` is in the data and use it for positioning. Pseudocode from the client confirms that for a given sprite node, the game just retrieves its origin and subtracts it from the world position when drawing. For example, if an object’s origin is meant to be the bottom-center, the draw routine will position the sprite so that bottom-center is at the map coordinate. Our Unity implementation attempts the same (setting the Unity object’s localPosition = `-origin.x, +origin.y` in Maple’s coordinate space). The fact that tiles align correctly and objects consistently appear too low by an amount proportional to their height strongly indicates we’re not applying the object’s actual origin. We’re effectively using (0,0) as the origin for all objects – which is the top-left of the image given our pivot – hence objects render sunk downwards (half or full height off).

From the research above, the fix is **not** that objects require a different origin or an additional offset; it’s that we must successfully *fetch the existing origin from the NX data*. The data for `houseGS`, `guide`, `signboard` etc. all have non-zero origin vectors (centered or bottom-centered points) in Map.nx. Once we obtain those, the Unity object placement will line up. The original client’s behavior and our data inspection confirm there’s no hidden special case – the origins are there in the NX structure for each object, just like for tiles.

**In conclusion**, to correctly align objects we should adjust our `SpriteLoader.GetOrigin` logic to ensure we’re reading the origin from the object’s frame node. That likely means: locating the proper NX node that contains the `origin` vector (possibly using the NX library’s point extraction if the direct child lookup fails), rather than climbing up parents that don’t have it. In practice, the origin is stored at the same level as the image’s width/height. For example, in the NX dump the *houseGS house9 basic 1* frame shows `{width:264, height:182, origin:(132,91)}` (indicating a centered origin) in its node. Our code should be grabbing that `(132,91)` and using it. By aligning our data extraction with the NX file structure – which is consistent between tiles and objects – we can obtain the correct origins and thus render all objects in sync with the tiles and other map elements.

**Sources:** Examination of MapleStory NX data for tiles and objects (showing `origin` fields in each image’s data), and MapleUnity debug/analysis notes confirming MapleStory uses the same origin-handling for all sprites. The misalignment is due to our Unity loader not pulling those object origin values, not due to a fundamental data omission. The original client’s draw logic and our findings underscore that the solution is to read the object origin from the correct node and apply it, just as we already do for tiles.