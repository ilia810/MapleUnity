# Background Tiling Algorithm in MapleStory’s C++ Client

## Viewport-Based Tiling Coverage (Not Full Map Width)

MapleStory’s original client determines background tiling based on the **viewport size**, not the total map dimensions or VR bounds. In the C++ code, the game defines a fixed *view width* and *view height* (e.g. 1024×768 in the open-source client) representing the on-screen area. For each background layer, it calculates how many tile sprites are needed to cover the screen plus a safety margin. Importantly, this calculation does **not** use the map’s full width or the VRLeft/VRRight values – it only uses the screen (view) size and the background image’s dimensions:

* **Tile size (`cx`,`cy`)**: The engine reads the background image’s width and height. If the map data’s `cx`/`cy` are zero, it defaults to the image’s own pixel dimensions. For example, *grassySoil* is a 256×256 texture, so `cx = 256`px and `cy = 256`px.
* **Tiles needed (`htile`,`vtile`)**: For a fully tiled background (Type 3), it computes:
  `htile = floor(VWIDTH / cx) + 3` and `vtile = floor(VHEIGHT / cy) + 3`.
  This means it divides the screen width by the tile width and adds 3 extra tiles, and does the same vertically. The “+3” is a fixed padding to ensure coverage beyond the edges. For example, if the view is \~2000px wide (in MapleStory units) and the tile is 256px, `htile` might be `floor(2000/256) + 3 = 7 + 3 = 10` tiles across. Smaller background types use a subset of this logic: Type 1 (horizontal tiled) only sets `htile` (horizontal repeat) and keeps one row (no vertical tiling), while Type 2 sets only `vtile`. Type 0 (normal) leaves both at 1 (no tiling). But **Type 3 backgrounds are explicitly set to tile in both directions across the entire viewport**.

> **Note:** The use of the **view width/height** (screen size) is key. The VR bounds (e.g. VRLeft = -1000, VRRight = 1000) from the map data define the camera’s movement limits, not the background size. In MapleStory’s code, if VR bounds are present and valid, they are used to clamp how far the camera can scroll horizontally/vertically. However, these values are **not** used to size the background fill area. The background tiling doesn’t “know” the total map span – it only cares about covering the **current view**. This is why the Maple client can have a map much wider than the screen yet still show background everywhere: it continually redraws the background as the view moves, rather than generating a one-time static sheet for the whole map.

## Full-Screen Tiled Backgrounds (Type 3) Logic

For **Type 3** backgrounds (the fully tiled layers like skies or base colors), the C++ client treats them as an *infinite repeating pattern* that always fills the screen. The rendering algorithm works as follows:

1. **Initial tile grid size:** Using the computed `htile` and `vtile` counts, the engine knows how large a grid of tiles to draw. For example, if `htile = 10` and `vtile = 10`, it plans to draw a 10×10 grid of the background image. The total coverage in world units would be `tw = cx * htile` by `th = cy * vtile` pixels. This area is deliberately larger than the viewport (due to the +3 margin) to cover the view and allow some leeway as the camera moves.

2. **Aligning to the camera:** Each frame, when the background is drawn, the code calculates where the top-left tile should be relative to the camera’s position (`viewx, viewy`). For static tiled backgrounds (no special motion), it uses the background’s scroll factor (`rx, ry`) to offset the texture with the camera. Essentially, it finds an initial `(x, y)` such that the tile pattern scrolls correctly with the camera. It then **wraps this offset into a single tile’s range** so that the tiles align with the screen. In code, it does:

   ```cpp
   if (htile > 1) {
       while (x > 0)  x -= cx;
       while (x < -cx) x += cx;
   }
   if (vtile > 1) {
       while (y > 0)  y -= cy;
       while (y < -cy) y += cy;
   }
   ```

   This ensures the starting `x` is between –1 tile width and 0 (and similarly for `y`). In simpler terms, it shifts the tile grid so that a tile boundary is just off-screen to the left/top. This way, you won’t see a partial gap; the tiling is seamless. As the camera moves, this offset will change slightly each frame, continuously wrapping around so the pattern stays consistent.

3. **Drawing the tiles:** After determining the aligned start `(ix, iy)` (rounded to nearest int), the engine draws the background by looping through the tile grid. It draws tiles in a nested loop: for `tx = 0` to `tw` in steps of `cx`, and `ty = 0` to `th` in steps of `cy`, it blits the background image at position `(ix + tx, iy + ty)`. This effectively paints a tiled mosaic covering an area slightly larger than the screen. For a Type 3 background like *grassySoil*, this means at any given moment there is a continuous 2D tiling of 256×256 patches filling the camera’s view (sky-blue texture in this case) behind all other map elements.

4. **Continuous tiling as you move:** Because the background is redrawn each frame relative to the camera, it **moves with you**. If the map is, say, 60+ Unity units wide (≈6000+ px in Maple terms), the camera will pan across that distance – and every frame, the code above will draw tiles centered around the camera. The result is that as you traverse from one end of the map to the other, the background pattern simply keeps repeating, always covering the visible area. There is never a need to explicitly size the background to 60 units; the algorithm inherently ensures that **wherever the camera is, the screen is filled**. In other words, the client doesn’t “know” it has to cover the entire 60-unit map at once – it only covers \~20 units at a time (the view width), but does so everywhere the camera goes. This gives the *illusion* that the background spans the whole map.

## VR Bounds vs. Map Extents vs. Background Coverage

It’s crucial to understand the distinction between **camera bounds** and **background tiling** in MapleStory’s engine:

* **VR Bounds (View Range)**: These are properties in the map data (VRLeft, VRRight, VRTop, VRBottom) that define how far the camera can scroll. In the C++ client, if a map provides VR bounds, they use them to set the limits (“walls”) for camera movement. If VR is missing or invalid, the client can derive camera bounds from the map’s content (footholds) plus a generous margin. **However, VR bounds do not determine the background’s tiling area.** They only ensure the camera doesn’t go beyond certain points (which usually prevents seeing beyond the designed map area or into blank space). In our example, Henesys had VRLeft/Right = ±1000 in the data – likely intended as default camera limits. The actual map geometry extended further, but the original client would still cap the camera around those values (unless overridden by content-based logic). The background rendering would still tile to the screen; if the camera can’t go further right than x=1000, players never notice that the map’s far-right tiles aren’t shown with background (the camera simply wouldn’t expose that region). **In short, VR bounds constrain the camera, but background tiling is always done relative to the camera’s view** – not by using the VR span as a tiling size.

* **Map Extents (actual content size)**: The real size of the map (e.g. tiles and objects reaching x ≈ 62.5 Unity units in Henesys) is not explicitly used in the tiling algorithm. The MapleStory client doesn’t pre-compute “map width” for backgrounds. It doesn’t, for example, create a 60-unit wide backdrop image. Instead, it continuously fills the **viewport**. This is why patching MapleUnity to use the full map bounds for one big background grid was a deviation – the original logic simply doesn’t do that. It’s not necessary because the background is **recomputed each frame** for the current camera position. The consequence is that in MapleStory you will never outrun the background; even if the map is three screens wide, the sky (Type 3 background) will always be drawn behind you on each screen as you move, rather than existing as a fixed finite panorama.

* **Viewport (View Width/Height)**: This is the foundational metric for background tiling. The C++ code uses a constant view size (which corresponds to the game’s window or resolution) to decide how many tiles to draw. For example, with a \~1024px wide view, they might draw \~7–10 tiles across depending on tile size. That ensures *at least* one screen width is covered at all times. The extra tiles (the “+3”) act as buffer so that even if the camera is between tile alignments or moves slightly, there’s no gap at the edges. Essentially, the background forms a rolling carpet under the camera that always extends past the screen edges. The **relationship is one-way**: the viewport size influences background tiling, but the map’s total size does not. Whether a map is 1 screen or 10 screens wide, the calculation for how many tiles to use at once is the same (it only changes if the user’s viewport size changes, e.g. different resolution).

**In summary**, the MapleStory C++ client handles a full-screen tiled background (Type 3) by *tiling it to the viewport* and moving that tiling along with the camera. It does not use the map’s VR bounds or actual width to decide the tiling extent. This algorithm ensures that a background like *grassySoil* (a 256×256 repeating patch) will cover the entire visible area at all times, and as the player moves, new tiles are drawn into view on the fly. Thus, the client “covers” a 60+ unit wide map by repeatedly filling a \~20-unit wide camera window as it pans across the map, rather than drawing a 60-unit span in one go. This dynamic tiling approach is the key to why the original game’s backgrounds seamlessly span large maps, and it’s the behavior MapleUnity needs to replicate for Type 3 backgrounds.

**Sources:**

1. MapleStory C++ client code – *Background tiling calculation and rendering*
2. MapleStory C++ client code – *Background type definitions and tiling counts (Type 3 vs others)*
3. MapleStory C++ client code – *Use of VR bounds for camera limits (unrelated to tiling area)*
