# Recreating MapleStory v83 Physics in MapleUnity

## MapleStory v83 Client Physics Overview

**Movement Constants:** The original MapleStory v83 client defines precise movement parameters. At 100% movement speed, the character walks at \~125 pixels per second (1.25 in MapleUnity’s unit scale) and jumps with an initial velocity of \~555 pixels/sec (5.55 units). Gravity accelerates the character downward at \~2000 px/s² (20 units/s²), with a terminal velocity (max fall speed) of \~670 px/s (6.7 units/s). These values were confirmed in **HeavenClient** (the open-source v83 C++ client) and have been adopted into MapleUnity’s `MaplePhysics` constants. MapleStory also defines distinct physics for special surfaces – for example, icy ground applies a very small horizontal acceleration (Slip Force \~0.05 units/s²) and low friction (Slip Drag \~0.9) to emulate sliding.

**Frame-Based Physics Calculation:** The MapleStory client uses a fixed-time-step physics loop tied to the frame rate. Each game tick, it updates velocities and positions using integer math to ensure deterministic, pixel-perfect movement. Horizontal movement in MapleStory is governed by **acceleration and friction** rather than immediate velocity changes. When an arrow key is held, the character’s horizontal velocity gradually ramps up toward the max walk speed, using a *Walk Force* (\~1.4 units/s², or 140 px/s²) applied each frame. This means a character takes a few frames to reach full speed (creating a subtle feeling of inertia). Conversely, when the key is released, MapleStory applies friction to slow the character down – the velocity is reduced by a *Walk Drag* (\~80 in internal units) each second, causing the character to coast briefly before stopping instead of halting instantly. In practical terms, MapleStory’s code likely does something akin to:

* **Acceleration:** `vx = min(vx + WalkForce*dt, WalkSpeed)` when moving (and similarly a negative acceleration for left movement). MapleUnity’s code comments note that MapleStory has “nearly instant acceleration,” implemented by using a very high acceleration value, but in reality the game does ramp speed over a few frames for smoothness.
* **Friction:** If no movement key is pressed, `vx` is gradually reduced. MapleUnity’s original logic subtracts friction each frame: `vx -= WalkDrag * dt` (clamping to 0), which matches MapleStory’s approach of quickly damping horizontal speed when input stops. There is **no air resistance** in MapleStory’s jump physics (airborne characters retain momentum), so if you jump while running and release the arrow key, you will continue moving forward in the air at the same speed until you land. You can even reverse direction mid-air, but only by overcoming your current momentum with opposite acceleration – the game applies the same walk force in mid-air (no extra drag), so changing direction takes a moment, preserving a very physical feel of momentum.

**Jumping and Gravity:** When the jump key is pressed (and the character is on ground), MapleStory sets the vertical velocity to a fixed **Jump Speed** (\~5.55 units or 555 px/s upward). This gives a consistent jump height and arc. Each frame thereafter, gravity subtracts about **20 units/s²** from the vertical velocity. The client clamps downward velocity to the **Max Fall Speed** (\~6.7 units/s or 670 px/s) so that the character doesn’t accelerate indefinitely while falling. In code, this is typically:

```cpp
vy -= Gravity * dt;
if(vy < -MaxFallSpeed) vy = -MaxFallSpeed;
```

(MapleUnity’s gravity helper illustrates this clamp.) The result is a characteristic MapleStory jump arc: a quick launch upward that peaks after a few tenths of a second, then a capped fall speed that makes downward motion steady. Notably, MapleStory’s jump is *binary* (no variable jump height by holding the key longer), but the engine does handle different jump stats – e.g. a higher Jump stat (%) simply scales the initial jump velocity.

**State Machine and Movement States:** The v83 client manages player physics through distinct movement states (Standing, Walking, Jumping, Climbing, etc.), much like MapleUnity’s `PlayerState`. The state machine logic dictates how input and physics are applied:

* **Standing:** Default state when idle on a platform. Horizontal velocity is zero (or brought to zero by friction), and gravity is not affecting the player (since they are grounded).
* **Walking:** Triggered when left/right input is pressed on ground. The character accelerates toward the walk speed in the input direction. Releasing the key transitions back to Standing after the residual motion decays. MapleStory likely transitions to “standing” state once horizontal velocity nearly zeroes out.
* **Jumping:** Set when a jump is initiated (from ground or dropping from a ladder). In this state, gravity is applied each frame to create the arc. The state persists for the entire airborne duration (both ascent and descent). Upon landing (vertical collision), the state changes from Jumping back to Standing or Walking. MapleStory distinguishes between jumping up vs. falling only for animation purposes, but the physics is continuous through the Jumping state.
* **Climbing:** Entered when the player contacts a ladder/rope and presses the climb key. In MapleStory, climbing disables gravity and horizontal movement, instead allowing fixed upward/downward movement at a set speed (e.g. \~120 px/s on ladders). The player’s state remains Climbing until they jump off or step off the ladder, at which point normal gravity resumes.

**Platform & Foothold Collision:** MapleStory maps are built from line segment “footholds” that define ground and platform surfaces. The client performs collision checks each frame to keep the player on top of these lines. When the player is in the air (Jumping state with `vy <= 0`, i.e. falling or moving downward), the physics code finds the highest foothold directly below the player’s horizontal position. It then predicts the player’s new vertical position for the next frame and checks if this crosses the foothold line’s height. In MapleUnity’s implementation, for example, they convert the player’s position to pixel coordinates and compute the platform’s Y at the player’s X (`GetYAtX`). If the character’s **previous bottom Y** was above the platform and the **new bottom Y** would be below it, a collision is detected. The engine then snaps the player to the foothold surface: set the player’s Y so their feet rest exactly on the platform, and zero out vertical velocity. At this moment, the code marks the player as grounded and fires a “landed” event, and the state machine transitions out of Jumping (e.g. to Standing).

MapleStory supports **one-way platforms** (footholds that you can jump up through from below, but land on from above) and **slopes**. The client’s foothold check inherently handles one-way behavior by only performing the landing check when falling downward; if the character is moving upward, they won’t land on a platform from below. The v83 client likely also has logic to allow players to drop down from one-way platforms by input (down+jump), temporarily disabling collision with that platform. Sloped footholds are handled by using linear interpolation (`GetYAtX`) to find the exact height of the ground at the player’s X position. This ensures the player stands perfectly on ramps. MapleUnity’s data structures mirror this: each `Platform` (foothold) has `X1, X2` endpoints and a function to get Y at a given X.

## MapleUnity’s Current Physics vs. MapleStory

The **current MapleUnity implementation (SimplePlayerController)** uses Unity’s 2D physics in a very simplified way, which leads to noticeable differences from authentic MapleStory movement. In the Unity prototype, the player is controlled by a `Rigidbody2D` with some basic parameters:

* **Movement Speed:** Constant 5 units/second horizontal speed (equates to 500 px/s) regardless of acceleration.
* **Jump Force:** A single impulse of 10 units (1000 px/s) applied when jumping.
* **Gravity Scale:** Set to 2.0 on the Rigidbody (approximately doubling Unity’s default gravity).

This yields a character that **starts, stops, and turns instantly**, and moves far faster than a MapleStory character. There is no simulation of momentum or gradual acceleration – as soon as you press a direction, the Rigidbody’s velocity is set to the fixed speed, and it drops to zero when released. In contrast, the MapleStory client had **gradual acceleration and deceleration**, so characters take a short time to get up to full speed and slide slightly to a stop. The absence of friction in the Unity controller makes movement feel twitchy compared to MapleStory’s smoother transitions.

**Jump physics** also differ. The Unity controller uses a single upward force and then relies on Unity’s continuous physics to bring the player back down. The jump height and timing are not tuned to MapleStory’s values – for example, a 10-unit impulse with gravity scale 2.0 does not produce the same jump arc as MapleStory’s 5.55-unit jump speed with gravity 20. The result is that the **character jumps higher and falls faster** (or slower, depending on Unity’s gravity settings) than in the original game, and the air control is unrealistic. In MapleUnity’s current build, the player can move horizontally in mid-air with the same 5 unit/s speed as on ground, effectively **full air control**. MapleStory by comparison preserves momentum: if you jump while running, you carry your horizontal velocity and **coast**. You can influence movement in air, but because there’s no air friction, changing direction is limited by the acceleration force. This means MapleStory players cannot instantly reverse direction mid-jump – a nuance not captured by the Unity rigidbody approach.

**Platform collisions and terrain:** The SimplePlayerController relies on Unity’s physics engine to handle collisions with the ground. Likely, colliders were generated for platforms or the tilemap, and the rigidbody simply collides and stands on them. While this achieves basic floor contact, it **lacks MapleStory’s nuanced platform behavior**. One-way platforms are probably not implemented (Unity colliders by default will block the player even when jumping upward, unless custom logic was added). Slopes would require polygon or edge colliders; if not set up exactly, the character might not smoothly slide up/down sloped ground as in MapleStory. Additionally, Unity’s engine might allow the player to “catch” onto edges or behave in ways MapleStory’s engine didn’t (e.g. Unity might treat the player as a continuous capsule, whereas MapleStory uses point-based collision on footholds). These differences can lead to the player either clipping through platforms or getting stuck, issues that were observed in the original MapleUnity physics attempt (e.g. *“platform collision detection completely broken (player fell through everything)”* when the custom physics was first tried). The current Unity-based fix resolved gross errors, but it sacrifices accuracy – for instance, **dropping down** through a platform or precise footing on slopes are not handled the same way as the original game.

**Summary of Key Differences:**

* *Acceleration:* MapleUnity (current) has instantaneous acceleration and stopping; MapleStory has high but finite acceleration, causing a brief ramp-up and slowdown.
* *Air Control:* MapleUnity allows full speed movement in air; MapleStory conserves momentum (no air drag) and requires time to accelerate or change direction mid-jump.
* *Jump Height/Gravity:* The Unity values are not tuned to MapleStory’s jump arc, leading to a different feel. MapleStory’s jump is shorter and snappier (with gravity capping fall speed) than the Unity version.
* *Platforms:* Unity physics doesn’t inherently support one-way platforms or the exact foothold logic. MapleStory’s collision system is custom-tailored for platformer behavior (one-way dropping, precise per-pixel ground contact on slopes), which is only crudely approximated by Unity’s default collision handling.
* *State synchronization:* In the current implementation, the **GameLogic vs GameView separation** was partly bypassed – the SimplePlayerController directly moves the Unity object, bypassing the `Player` logic class. This can cause the visual and logical states to diverge. (For example, previously the camera followed the logic Player object that was falling due to a bug, while the visible rectangle was controlled separately.) Maintaining the player state (standing/jumping, etc.) in sync with the visual could be an issue if Unity physics and the logic state machine aren’t tightly coupled.

## Plan for Authentic Physics Implementation

To achieve **frame-perfect MapleStory physics** in MapleUnity, the Unity project should pivot away from Unity’s built-in physics for player movement and instead port the original MapleStory physics model. The following plan addresses the key aspects:

### 1. **Port MapleStory’s Physics Code and Frame Logic**

The most direct path to authenticity is to reimplement the MapleStory v83 movement formulas within MapleUnity’s GameLogic, bypassing Unity’s physics for player motion. This means using MapleStory’s known constants and updating the player’s position manually each tick, exactly as the client does.

* **Use FixedUpdate at 60 FPS:** Configure Unity’s fixed timestep to **0.01667s** (60 Hz) to mirror MapleStory’s frame rate. All physics updates will occur in `FixedUpdate` so that we simulate on a frame-by-frame basis like the original. The simulation step (dt) will be a constant (e.g. 16ms), matching the deterministic nature of the client’s loop.

* **Integer-accurate calculations:** Wherever possible, perform movement and collision math in Maple’s native units (pixels) or an integer/fixed-point representation. MapleStory uses integer pixel coordinates for positions and likely fixed-point for velocity. We can mirror this by scaling all positions by 100 (as we’ve done, where 1 Unity unit = 100 pixels) and using integers for critical checks. For example, the player’s position could be tracked as an `Vector2Int` in pixels for collision detection, while we still update a float for smooth rendering. Ensuring we round or truncate consistently (e.g. always floor when converting to int) will make landing on a platform happen at the exact same pixel Y as in MapleStory. This will eliminate the tiny discrepancies that can accumulate if we rely purely on floats. In practice, we might keep the `Player.Position` in Unity units for convenience but be very careful with conversion – the final **Final Fixes** in MapleUnity already moved toward not over-scaling the position. The key is to **not** divide by 100 when updating the Unity transform (we now treat the logic values as Unity world units directly). We'll continue that approach: use the MaplePhysics constants (which are in Unity units already for convenience) and ensure 1.25 units translates to exactly 125px movement on screen.

* **Horizontal movement formula:** Replace the current “instant velocity” input handling with MapleStory’s acceleration model. Instead of setting `velocity.x = ±WalkSpeed` immediately on key press, we will apply a force toward the target speed:

  * If player presses Right and current `vx < WalkSpeed`, then `vx += WalkForce * dt` (and vice versa for Left). Clamp `vx` to ±WalkSpeed. Use the MaplePhysics values for WalkForce (approx 1.4 units/s²) so that acceleration rate matches v83.
  * If no horizontal input, apply friction: e.g. `vx -= WalkDrag * dt` toward 0. Using the Maple v83 drag (80) and our 60 Hz tick, this will reduce the speed by \~1.33 units per second (which over a few frames brings the character to a stop, just like in the original). **Important:** Only apply ground friction when the character is on a platform; if the player is mid-air (jumping/falling), do **not** apply horizontal drag (Maple’s air drag is zero). This way, momentum is preserved during jumps. MapleUnity’s MaplePhysics already has `FallDrag = 0` to reflect this.
  * By doing this in FixedUpdate, we effectively replicate MapleStory’s frame-by-frame velocity updates. Over many frames, the motion curve (acceleration to top speed, then deceleration) will mirror the original game’s feel. The controlled acceleration also prevents the slippery instant starts we have now.

* **Vertical movement formula:** Implement jumps and gravity exactly as MapleStory:

  * On jump: if the player is grounded (State = Standing/Walking) and jump is pressed, set `vy = JumpSpeed` (using 5.55 units from MaplePhysics for a base 100% jump, modified by the character’s jump stat if applicable via `GetJumpPower` formula). Also set state to Jumping and `IsGrounded = false`.
  * Each frame, apply gravity: `vy -= Gravity * dt`. Use 20 units/s²; at 60fps dt, that subtracts \~0.333 units (33.3 px/s) each tick. Clamp `vy` to not go below -6.7 units (terminal velocity). MapleUnity’s helper `MaplePhysics.ApplyGravity()` already does this logic. This ensures the fall speed and overall jump duration match the original. For example, starting at +5.55, gravity 20 will make the character rise for \~17 frames (\~0.27s) before `vy` flips sign, and then fall at a steady \~6.7 units/s max – exactly replicating MapleStory’s jump arc.
  * When the player is on a ladder/rope (State = Climbing), skip gravity entirely and instead handle vertical movement via input: if Up pressed, `vy = +ClimbSpeed` (e.g. \~1.2 units/s for 120 px/s); if Down pressed, `vy = -ClimbSpeed`; if no input, `vy = 0`. While climbing, ignore horizontal input (or optionally allow a little horizontal to switch between adjacent ladders if MapleStory did so). If jump is pressed while climbing, simulate a jump off the ladder: exit Climbing state, and apply the jump velocity to launch the character off.

* **Update Position:** After computing the new `vx, vy` for the frame, update the player’s position: `position += velocity * dt`. With our units, dt=1/60 and velocity in units/s, this will increment position by a small amount each tick. Because we’re using the same units and dt as MapleStory, the positional movement per frame will match the pixel movement of the original. This integration should be done in the logic (`Player.UpdatePhysics`), not by Unity’s physics engine. Essentially, we will **turn the player into a kinematic object** that we move manually.

* **Maintain State Machine:** Ensure that as we apply these physics, we also update `Player.State` appropriately. For example:

  * If `vx` was 0 and now is >0 (or <0), transition state from Standing to Walking.
  * If the player was in Walking and input released (no input and after friction brings `vx` near 0), transition back to Standing.
  * If jump occurs, set state to Jumping; if the player lands from a jump, set state to Standing or Walking depending on whether horizontal input is still active.
  * These state changes will drive the MapleCharacterRenderer to play the correct animations (walk, jump, etc.), preserving the visual authenticity as well.

By porting these mechanics, we essentially recreate MapleStory’s physics engine inside Unity. This addresses the core movement feel issues – acceleration, momentum, jump height – at the code level.

### 2. **Foothold Collision and One-Way Platforms**

Accurate platform interaction is critical. We will replace Unity’s generic collision response with MapleStory’s foothold logic using the map data (which we already have parsed from NX).

* **Use Map Data for Ground Collision:** Continue to use the `MapData.Platforms` list (footholds) and the collision detection approach similar to `Player.GetPlatformBelow()` in GameLogic. After updating the tentative new position each frame, do:

  * If vertical velocity `vy` is downward or zero (meaning the player is falling or was propelled downwards), check for a platform directly below. Find candidate footholds under the player’s horizontal position (X), likely by filtering those with `X1 <= playerX <= X2` and within a reasonable vertical range. Among these, find the one with the highest Y coordinate that is still below the player’s **previous** position.
  * Compute the Y of that foothold at the player’s X (`platformY = foothold.GetYAtX(playerX)`). We have this function; it linearly interpolates on sloped lines.
  * Determine the player’s foot Y coordinate (player’s center Y minus half height, since height \~60px) for both the previous position and the new projected position. If the previous foot was above the platform and the new foot is at or below the platform (crossing it), we have a collision (the player is landing on that platform this frame).
  * Snap the player’s position Y to the platform surface: `newPos.y = platformY + (height/2)` so that the feet sit exactly on it. Then set `vy = 0` (the player stops falling) and mark them grounded (`IsGrounded = true`). Also trigger the Landed event and state change out of Jumping as done in our logic.
  * If no platform is found within reach (or the player was moving upwards), let the position update go through (the player stays in air).

* **One-Way Platform Handling:** The above logic naturally handles landing from above, but we need to implement **drop-down** and jumping through platforms:

  * When the player presses the down arrow + jump while standing on a one-way platform, we should allow them to fall through. We can implement this by setting a flag on the player (e.g. `dropping = true`) when that input combo is detected. If `dropping` is true, temporarily ignore one-way platforms in the collision check (i.e. filter them out or skip the landing logic for those) until the player has moved below the platform. Once the player is below, clear the flag so they can land on other platforms again. This mimics MapleStory’s drop-down feature.
  * Ensure that purely vertical upward movement doesn’t cause landing on one-way platforms from below. Our check already only runs when `vy <= 0`, so a jumping player going up will pass through any platforms above.
  * We may also use Unity’s collider as a trigger (for example, add a trigger collider to one-way platforms) to detect when the player’s head intersects a platform from below and use that to prevent landing, but since we have full control via logic, it’s simpler to just not perform the snap if coming from below.

* **Slope accuracy:** The interpolation method (`GetYAtX`) will ensure the player’s Y aligns to the slope geometry. We should also update horizontal position without any further adjustment from Unity physics, to prevent Unity’s engine from erroneously “pushing” the player up slopes. Our manual repositioning each frame effectively overrides Unity, so this should be fine. We just need to be sure to consider wide movements: if the player’s horizontal speed is high, they might traverse a very narrow platform in one frame. However, MapleStory’s speeds are low (max \~125px/s) relative to platform sizes, so a 16ms frame move (\~2px) is small – tunneling through platforms won’t be an issue at these speeds. (If it were, we’d subdivide the movement or do a raycast between old and new positions, but it’s likely unnecessary given Maple’s parameters.)

* **Colliders Setup:** Since we will trust our custom collision, the player’s Unity collider can be kept non-solid (e.g. `isTrigger=true` as in the original PlayerView) or even removed, to avoid interfering with our logic. The environment colliders (if any were added for the temporary Rigidbody solution) should either be removed or set to triggers so they don’t produce a physics response. Essentially, we will revert to using colliders only for things like enemy contact or ladder regions, not for ground collision resolution. If needed, we might keep a very simple collider for the player just for detecting ladder triggers or other interactive regions, but not for physics forces.

* **Ladders:** For ladder regions (ropes/ladders in maps), MapleUnity’s `LadderInfo` data can be used to determine if the player is in range to start climbing. We can use either a trigger collider that covers the ladder area or simply check the player’s position against ladder coordinates each frame. When the up/down climb input is detected and the player’s position overlaps a ladder segment, call `StartClimbing()` (as already implemented in `Player.cs`). This will set the state to Climbing and zero out velocity, etc. While Climbing, handle movement as described (move up/down at constant speed). On jump or reaching the top/bottom, call `StopClimbing()` to return to normal physics.

By handling ground contact and ladders in code, we ensure the **collision outcomes are identical to MapleStory**. The character will only ever land when and where the original would, and can drop down through platforms in the same manner. We eliminate the oddities of Unity’s physics (such as catching edges or bouncing).

### 3. **Integrating with MapleUnity Architecture**

Integrating this physics overhaul requires careful coordination between the **GameLogic** (pure physics/inputs) and **GameView** (Unity rendering) layers:

* **Centralize Player Update:** We should reinstate `Player` (GameLogic) as the authoritative representation of the player’s state and movement, and use the Unity `GameObject` only as a visual representation. That means the `SimplePlayerController` MonoBehaviour (or a new controller script) will no longer set the Rigidbody velocity; instead it will:

  1. Read player input each frame (or each FixedUpdate) – e.g. check `Input.GetKey` for left/right and jump.
  2. Call the corresponding methods on the `Player` object: `Player.MoveLeft(true/false)`, `Player.MoveRight(true/false)` and `Player.Jump()`, etc. We already have these methods in `Player.cs` for toggling movement flags.
  3. In FixedUpdate, call `Player.UpdatePhysics(deltaTime, currentMapData)` to advance the player’s position using our custom physics. We pass in `deltaTime` = 1/60 (or use Unity’s `Time.fixedDeltaTime`) and the map data for collision checks.
  4. After physics is updated, take the resulting `Player.Position` and apply it to the Unity `Transform` of the player’s GameObject. This was originally done in `PlayerView.Update()` (dividing by 100); now that we’ve fixed the scaling issue, we will simply set `transform.position = new Vector3(player.Position.X, player.Position.Y, 0)` (assuming our Player.Position is already in Unity world units). This ensures the visual sprite follows the logic exactly. We should do this in LateUpdate or just after physics update to avoid a one-frame lag.

* **Disable Unity Physics on Player:** Remove or deactivate the `Rigidbody2D` on the player object, since we don’t want Unity’s physics system to move the player. The player will be moved by setting transform.position directly each frame (kinematic motion). As long as the player’s collider is a trigger or removed, this won’t cause physics conflicts. The camera can continue to follow the player object as it does now (since we’re updating the transform, the camera will track it normally).

* **Consistency Between Assemblies:** We need to be mindful of the split between GameLogic and GameView. The `Player` class lives in GameLogic, and `SimplePlayerController`/MonoBehaviours live in GameView. We’ll ensure the Player instance is created and managed by the Game (likely through a GameManager or similar). For example, the map generation could spawn a Player logic object and a corresponding Unity GameObject (with PlayerView or controller attached). We then link them via something like `PlayerView.SetPlayer(player)` as was done originally. After that, all input/physics will route through the Player object.

* **Address Prior Issues:** The original attempt had issues with the camera following an “invisible” logic object – this was because the visual sprite (MapleCharacterRenderer) got out of sync. In our new integration, the visual GameObject **is** the object the camera follows (as before), but now we directly set its transform from Player.Position each frame. We have effectively the same setup, but we know Player.Position will be updating correctly (no divide-by-100 confusion). The fallback renderer ensures a visible sprite is always present, so the camera should always have something to center on. We should test that the camera’s target is indeed the GameObject we move; if it was following the logic position via some other means, we’ll adjust it to follow the visual.

* **Testing & Iteration:** After implementing, thorough testing is needed:

  * Verify that walking/jumping feels identical to MapleStory (distance traveled, time to stop, etc.). We can compare with the values from MapleStory or even record a small segment from the v83 client for position over time.
  * Ensure landing on platforms is pixel-perfect (the player should never hover above or sink into platforms). If any discrepancies appear (e.g. due to float precision), consider switching more of the math to integer. The Final Fixes report indicates we resolved a major scale bug and now achieve correct speed, which is a good sign for our unit consistency.
  * Check one-way platform behavior (land from above, drop from platform) matches expectations.
  * Check ladder transitions (mounting/dismounting ladders and ropes).
  * Confirm that animations (via MapleCharacterRenderer) still trigger correctly based on `Player.State` changes. For instance, the renderer calls `GetCharacterState()` mapping PlayerState to animation on each Update – this should continue to work since we are using the same PlayerState enum and setting it in our physics logic. We might need to add a slight delay or condition for the Jump->Stand state change to match MapleStory’s animation timing (MapleStory may play a landing animation frame; in MapleUnity we might directly set to Standing the moment of landing, which is usually fine).

### 4. **Preserving the Authentic Feel**

Finally, we should incorporate any remaining subtleties from MapleStory’s physics to truly nail the feel:

* **Momentum and Air Control:** As noted, MapleStory movement has inertia. By implementing acceleration and zero air friction, we get this inherently. We should be careful not to re-introduce any unintended damping. For example, ensure that our friction code is **not** running while jumping (in our `Player.UpdateHorizontalVelocity` or equivalent, only apply friction if grounded). MapleUnity’s current code partially does this by only calling friction when no input and the state is Walking on ground. We’ll extend that logic appropriately.

* **Edge Cases (“Coyote Time” and Input Buffer):** MapleStory v83 is an old-school game and generally does not have modern platformer features like coyote time (a small grace period to jump after leaving a ledge). It likely strictly requires being grounded to jump. We will keep that behavior: require `IsGrounded` true to allow jumping. If anything, MapleStory might have a *jump input buffering* of a few frames (so if you hit jump just before landing, it triggers on landing). This is not documented for v83, but we can observe if such behavior exists. If players notice something is off, we could consider a tiny buffer: e.g. if jump is pressed within X ms before landing, perform the jump on landing. This would make the game more forgiving without altering physics. It’s an optional enhancement; authenticity can be prioritized (likely MapleStory did *not* have this in 2008).

* **Multiple Jump Types:** In v83, certain classes had alternative jumps (e.g. the Thief’s Flash Jump, double jumps for some jobs). Our implementation should be flexible to handle these. For example, a second jump in mid-air would apply a smaller additional vertical velocity (MaplePhysics defines `DoubleJumpModifier = 0.7` and uses the same JumpSpeed for a double jump but scaled by 0.7). We should ensure the physics system can accommodate that: e.g. allow `Player.Jump()` to be called when already in Jumping state if the character has a double-jump skill, and then set `vy = DoubleJumpSpeed` (maybe overriding current downward velocity if any). This ensures that when we later add skills, the system can still produce faithful behavior.

* **Interaction with Mobs/Knockback:** MapleStory physics also include knockback from enemy hits – the values for that (e.g. being pushed back with a horizontal and upward velocity) are defined in MaplePhysics (`GetKnockback` gives a force based on damage). We should integrate that by setting the player’s velocity to the knockback vector and maybe a brief stun. Our physics loop will then carry out the knockback motion (gravity will bring the player down, friction will slow horizontal movement as they skid to a stop). This will look identical to MapleStory’s knockback if we use the same values.

* **Testing with Real Data:** After implementing, compare the MapleUnity player’s movement against the original. For example, at 100% speed stat, how many frames does it take to cover a certain distance in both MapleUnity and MapleStory? It should match within a fraction of a pixel. The **MapleUnity debug tools** can help here: the PlayerDebugVisual or logging can output velocity and position per frame, which we can use to verify the acceleration curve matches MapleStory’s known values (like how many frames to reach 125 px/s, etc.). Fine-tune the constants if needed, but since we have the exact numbers from MapleStory now, it should be close.

By following these steps, we will have effectively transplanted the MapleStory v83 physics engine into Unity. The player’s movement, jump arcs, and platform interactions will **exactly mirror the original game**, providing the authentic feel that was missing. Unity’s role will be reduced to rendering and detecting inputs, which is appropriate – the heavy lifting of physics will be handled by our MapleStory logic.

## Conclusion

**Implementing MapleStory-accurate physics in MapleUnity** requires abandoning the naive Rigidbody approach and embracing a custom, frame-step simulation. We will draw directly from the v83 client’s formulas: using MapleStory’s pixel-based speeds, accelerations, and gravity to update the player’s position each 1/60th of a second. Collisions will be handled through the same foothold logic the original game used, enabling one-way platforms and slopes to function identically. This plan maintains the separation of GameLogic and GameView – the GameLogic `Player` will govern all movement and state, while Unity’s MonoBehaviours simply feed input to it and render the results.

By carefully accounting for the coordinate system differences (pixels vs. Unity units) and using the known constants, we ensure **frame-perfect accuracy** – the character will move the same number of pixels per frame as in MapleStory. Players will immediately notice the improvement: acceleration and deceleration will feel “right,” jumps will reach the expected height, and platform navigation will have the familiar MapleStory smoothness and quirks (like slipping on ice or jumping down from platforms). In short, this approach swaps out Unity’s physics for MapleStory’s own physics engine, yielding an authentic gameplay experience while still leveraging Unity for rendering and other systems.

With this groundwork in place, MapleUnity can truly behave like MapleStory v83, allowing us to expand further (skills, combat, etc.) on a solid, authentic-feeling foundation. The end result will be a MapleUnity that not only looks like MapleStory, but **moves** like MapleStory – capturing that nostalgic platforming feel that players expect.

**Sources:**

* MapleUnity internal documentation and code (MaplePhysics constants, Player movement logic)
* HeavenClient v83 C++ client constants (via MapleUnity commits)
* MapleUnity issue trackers and fix reports (movement fixes and physics plans)
